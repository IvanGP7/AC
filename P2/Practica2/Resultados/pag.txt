sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 4 4 2 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 21:43:24 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      4 4 2 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 64 # total simulation time in seconds
sim_inst_rate          1562500.0156 # simulation speed (in insts/sec)
sim_total_insn            116564312 # total number of instructions executed
sim_total_refs             35323866 # total number of loads and stores executed
sim_total_loads            26873011 # total number of loads executed
sim_total_stores       8450855.0000 # total number of stores executed
sim_total_branches         23303015 # total number of branches executed
sim_cycle                1049883859 # total simulation time in cycles
sim_IPC                      0.0952 # instructions per cycle
sim_CPI                     10.4988 # cycles per instruction
sim_exec_BW                  0.1110 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4121266991 # cumulative IFQ occupancy
IFQ_fcount               1025373094 # cumulative IFQ full count
ifq_occupancy                3.9255 # avg IFQ occupancy (insn's)
ifq_rate                     0.1110 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 35.3562 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9767 # fraction of time (cycle's) IFQ was full
RUU_count               16458207509 # cumulative RUU occupancy
RUU_fcount               1006411218 # cumulative RUU full count
ruu_occupancy               15.6762 # avg RUU occupancy (insn's)
ruu_rate                     0.1110 # avg RUU dispatch rate (insn/cycle)
ruu_latency                141.1942 # avg RUU occupant latency (cycle's)
ruu_full                     0.9586 # fraction of time (cycle's) RUU was full
LSQ_count                8084652882 # cumulative LSQ occupancy
LSQ_fcount                984908209 # cumulative LSQ full count
lsq_occupancy                7.7005 # avg LSQ occupancy (insn's)
lsq_rate                     0.1110 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 69.3579 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9381 # fraction of time (cycle's) LSQ was full
sim_slip                24431847599 # total number of slip cycles
avg_sim_slip               244.3185 # the average slip between issue and retirement
bpred_2lev.lookups         24084991 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       17638793 # total number of address-predicted hits
bpred_2lev.dir_hits        17669765 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2981253 # total number of misses
bpred_2lev.jr_hits          1113979 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8541 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8556 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9731 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1659267 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1382265 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1110919 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9730 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              122666185 # total number of accesses
il1.hits                  122035968 # total number of hits
il1.misses                   630217 # total number of misses
il1.replacements             629893 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0051 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0051 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               28236414 # total number of accesses
dl1.hits                   24878728 # total number of hits
dl1.misses                  3357686 # total number of misses
dl1.replacements            3357174 # total number of replacements
dl1.writebacks                43876 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1189 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1189 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4031779 # total number of accesses
ul2.hits                     689119 # total number of hits
ul2.misses                  3342660 # total number of misses
ul2.replacements            3339288 # total number of replacements
ul2.writebacks                27460 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8291 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8282 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             122666185 # total number of accesses
itlb.hits                 122666164 # total number of hits
itlb.misses                      21 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              31633790 # total number of accesses
dtlb.hits                  29564992 # total number of hits
dtlb.misses                 2068798 # total number of misses
dtlb.replacements           2068670 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0654 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0654 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              259416 # total first level page table misses
mem.ptab_accesses        1182659588 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 8 16 4 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 21:44:28 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      8 16 4 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 63 # total simulation time in seconds
sim_inst_rate          1587301.6032 # simulation speed (in insts/sec)
sim_total_insn            113602570 # total number of instructions executed
sim_total_refs             32860579 # total number of loads and stores executed
sim_total_loads            25548263 # total number of loads executed
sim_total_stores       7312316.0000 # total number of stores executed
sim_total_branches         23368140 # total number of branches executed
sim_cycle                1041598175 # total simulation time in cycles
sim_IPC                      0.0960 # instructions per cycle
sim_CPI                     10.4160 # cycles per instruction
sim_exec_BW                  0.1091 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4089216672 # cumulative IFQ occupancy
IFQ_fcount               1017062666 # cumulative IFQ full count
ifq_occupancy                3.9259 # avg IFQ occupancy (insn's)
ifq_rate                     0.1091 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 35.9958 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9764 # fraction of time (cycle's) IFQ was full
RUU_count               16342507478 # cumulative RUU occupancy
RUU_fcount                998412226 # cumulative RUU full count
ruu_occupancy               15.6898 # avg RUU occupancy (insn's)
ruu_rate                     0.1091 # avg RUU dispatch rate (insn/cycle)
ruu_latency                143.8568 # avg RUU occupant latency (cycle's)
ruu_full                     0.9585 # fraction of time (cycle's) RUU was full
LSQ_count                8042825794 # cumulative LSQ occupancy
LSQ_fcount                984458212 # cumulative LSQ full count
lsq_occupancy                7.7216 # avg LSQ occupancy (insn's)
lsq_rate                     0.1091 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 70.7979 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9451 # fraction of time (cycle's) LSQ was full
sim_slip                24448785818 # total number of slip cycles
avg_sim_slip               244.4879 # the average slip between issue and retirement
bpred_2lev.lookups         24177094 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       17757195 # total number of address-predicted hits
bpred_2lev.dir_hits        17795719 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2855299 # total number of misses
bpred_2lev.jr_hits          1106422 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8599 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8617 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9665 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1387975 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1296453 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1103362 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9664 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              119265346 # total number of accesses
il1.hits                  118643122 # total number of hits
il1.misses                   622224 # total number of misses
il1.replacements             621896 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0052 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0052 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27593509 # total number of accesses
dl1.hits                   24235046 # total number of hits
dl1.misses                  3358463 # total number of misses
dl1.replacements            3357951 # total number of replacements
dl1.writebacks                43922 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1217 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1217 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4024609 # total number of accesses
ul2.hits                     681350 # total number of hits
ul2.misses                  3343259 # total number of misses
ul2.replacements            3339887 # total number of replacements
ul2.writebacks                27492 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8307 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8299 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             119265346 # total number of accesses
itlb.hits                 119265325 # total number of hits
itlb.misses                      21 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              31007297 # total number of accesses
dtlb.hits                  28937455 # total number of hits
dtlb.misses                 2069842 # total number of misses
dtlb.replacements           2069714 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0668 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0667 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              253152 # total first level page table misses
mem.ptab_accesses        1170926428 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 16 64 6 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 21:45:32 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      16 64 6 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 63 # total simulation time in seconds
sim_inst_rate          1587301.6032 # simulation speed (in insts/sec)
sim_total_insn            111565644 # total number of instructions executed
sim_total_refs             32840009 # total number of loads and stores executed
sim_total_loads            25361906 # total number of loads executed
sim_total_stores       7478103.0000 # total number of stores executed
sim_total_branches         22830502 # total number of branches executed
sim_cycle                1038974938 # total simulation time in cycles
sim_IPC                      0.0962 # instructions per cycle
sim_CPI                     10.3897 # cycles per instruction
sim_exec_BW                  0.1074 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4090477606 # cumulative IFQ occupancy
IFQ_fcount               1017853825 # cumulative IFQ full count
ifq_occupancy                3.9370 # avg IFQ occupancy (insn's)
ifq_rate                     0.1074 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 36.6643 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9797 # fraction of time (cycle's) IFQ was full
RUU_count               16344788186 # cumulative RUU occupancy
RUU_fcount               1001520280 # cumulative RUU full count
ruu_occupancy               15.7316 # avg RUU occupancy (insn's)
ruu_rate                     0.1074 # avg RUU dispatch rate (insn/cycle)
ruu_latency                146.5038 # avg RUU occupant latency (cycle's)
ruu_full                     0.9640 # fraction of time (cycle's) RUU was full
LSQ_count                8044387365 # cumulative LSQ occupancy
LSQ_fcount                985156338 # cumulative LSQ full count
lsq_occupancy                7.7426 # avg LSQ occupancy (insn's)
lsq_rate                     0.1074 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 72.1045 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9482 # fraction of time (cycle's) LSQ was full
sim_slip                24462996929 # total number of slip cycles
avg_sim_slip               244.6300 # the average slip between issue and retirement
bpred_2lev.lookups         23421230 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       18443985 # total number of address-predicted hits
bpred_2lev.dir_hits        18479697 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2171321 # total number of misses
bpred_2lev.jr_hits          1109231 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8931 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8949 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9690 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1426208 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1293476 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1106171 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9689 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              116043141 # total number of accesses
il1.hits                  115414074 # total number of hits
il1.misses                   629067 # total number of misses
il1.replacements             628741 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0054 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0054 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27511665 # total number of accesses
dl1.hits                   24154871 # total number of hits
dl1.misses                  3356794 # total number of misses
dl1.replacements            3356282 # total number of replacements
dl1.writebacks                43908 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1220 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1220 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4029769 # total number of accesses
ul2.hits                     688348 # total number of hits
ul2.misses                  3341421 # total number of misses
ul2.replacements            3338048 # total number of replacements
ul2.writebacks                27484 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8292 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8283 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             116043141 # total number of accesses
itlb.hits                 116043119 # total number of hits
itlb.misses                      22 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              30953929 # total number of accesses
dtlb.hits                  28885240 # total number of hits
dtlb.misses                 2068689 # total number of misses
dtlb.replacements           2068561 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0668 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0668 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              258609 # total first level page table misses
mem.ptab_accesses        1163723178 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 256 8 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 21:46:36 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 256 8 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 66 # total simulation time in seconds
sim_inst_rate          1515151.5303 # simulation speed (in insts/sec)
sim_total_insn            109603992 # total number of instructions executed
sim_total_refs             32294100 # total number of loads and stores executed
sim_total_loads            24964368 # total number of loads executed
sim_total_stores       7329732.0000 # total number of stores executed
sim_total_branches         22435229 # total number of branches executed
sim_cycle                1036437551 # total simulation time in cycles
sim_IPC                      0.0965 # instructions per cycle
sim_CPI                     10.3644 # cycles per instruction
sim_exec_BW                  0.1058 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4090783338 # cumulative IFQ occupancy
IFQ_fcount               1018536326 # cumulative IFQ full count
ifq_occupancy                3.9470 # avg IFQ occupancy (insn's)
ifq_rate                     0.1058 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 37.3233 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9827 # fraction of time (cycle's) IFQ was full
RUU_count               16344951758 # cumulative RUU occupancy
RUU_fcount               1003651696 # cumulative RUU full count
ruu_occupancy               15.7703 # avg RUU occupancy (insn's)
ruu_rate                     0.1058 # avg RUU dispatch rate (insn/cycle)
ruu_latency                149.1273 # avg RUU occupant latency (cycle's)
ruu_full                     0.9684 # fraction of time (cycle's) RUU was full
LSQ_count                8044587630 # cumulative LSQ occupancy
LSQ_fcount                985535648 # cumulative LSQ full count
lsq_occupancy                7.7618 # avg LSQ occupancy (insn's)
lsq_rate                     0.1058 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 73.3968 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9509 # fraction of time (cycle's) LSQ was full
sim_slip                24475385184 # total number of slip cycles
avg_sim_slip               244.7538 # the average slip between issue and retirement
bpred_2lev.lookups         22925132 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       19101052 # total number of address-predicted hits
bpred_2lev.dir_hits        19122708 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1528310 # total number of misses
bpred_2lev.jr_hits          1123293 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9249 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9260 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9812 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1393506 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1254682 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1120233 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9812 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              113697245 # total number of accesses
il1.hits                  113057690 # total number of hits
il1.misses                   639555 # total number of misses
il1.replacements             639232 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0056 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0056 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27360476 # total number of accesses
dl1.hits                   24003206 # total number of hits
dl1.misses                  3357270 # total number of misses
dl1.replacements            3356758 # total number of replacements
dl1.writebacks                43927 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1227 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1227 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4040752 # total number of accesses
ul2.hits                     698353 # total number of hits
ul2.misses                  3342399 # total number of misses
ul2.replacements            3339027 # total number of replacements
ul2.writebacks                27504 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8272 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8263 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             113697245 # total number of accesses
itlb.hits                 113697223 # total number of hits
itlb.misses                      22 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              30771482 # total number of accesses
dtlb.hits                  28702480 # total number of hits
dtlb.misses                 2069002 # total number of misses
dtlb.replacements           2068874 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0672 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0672 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              258968 # total first level page table misses
mem.ptab_accesses        1157707522 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 64 1024 10 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 21:47:43 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      64 1024 10 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 63 # total simulation time in seconds
sim_inst_rate          1587301.6032 # simulation speed (in insts/sec)
sim_total_insn            106758329 # total number of instructions executed
sim_total_refs             31927269 # total number of loads and stores executed
sim_total_loads            24686345 # total number of loads executed
sim_total_stores       7240924.0000 # total number of stores executed
sim_total_branches         21947233 # total number of branches executed
sim_cycle                1033864617 # total simulation time in cycles
sim_IPC                      0.0967 # instructions per cycle
sim_CPI                     10.3386 # cycles per instruction
sim_exec_BW                  0.1033 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4087800810 # cumulative IFQ occupancy
IFQ_fcount               1017802927 # cumulative IFQ full count
ifq_occupancy                3.9539 # avg IFQ occupancy (insn's)
ifq_rate                     0.1033 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 38.2902 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9845 # fraction of time (cycle's) IFQ was full
RUU_count               16341750120 # cumulative RUU occupancy
RUU_fcount               1004204916 # cumulative RUU full count
ruu_occupancy               15.8065 # avg RUU occupancy (insn's)
ruu_rate                     0.1033 # avg RUU dispatch rate (insn/cycle)
ruu_latency                153.0724 # avg RUU occupant latency (cycle's)
ruu_full                     0.9713 # fraction of time (cycle's) RUU was full
LSQ_count                8043872165 # cumulative LSQ occupancy
LSQ_fcount                985083345 # cumulative LSQ full count
lsq_occupancy                7.7804 # avg LSQ occupancy (insn's)
lsq_rate                     0.1033 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 75.3466 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9528 # fraction of time (cycle's) LSQ was full
sim_slip                24470823682 # total number of slip cycles
avg_sim_slip               244.7082 # the average slip between issue and retirement
bpred_2lev.lookups         22359414 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       19557145 # total number of address-predicted hits
bpred_2lev.dir_hits        19586980 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1064038 # total number of misses
bpred_2lev.jr_hits          1115112 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9470 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9485 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9741 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1354153 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1245913 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1112052 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9740 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              109759783 # total number of accesses
il1.hits                  109133676 # total number of hits
il1.misses                   626107 # total number of misses
il1.replacements             625786 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0057 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0057 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27265736 # total number of accesses
dl1.hits                   23908775 # total number of hits
dl1.misses                  3356961 # total number of misses
dl1.replacements            3356449 # total number of replacements
dl1.writebacks                43889 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1231 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1231 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4026957 # total number of accesses
ul2.hits                     684805 # total number of hits
ul2.misses                  3342152 # total number of misses
ul2.replacements            3338779 # total number of replacements
ul2.writebacks                27476 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8299 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8291 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             109759783 # total number of accesses
itlb.hits                 109759762 # total number of hits
itlb.misses                      21 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              30683077 # total number of accesses
dtlb.hits                  28614501 # total number of hits
dtlb.misses                 2068576 # total number of misses
dtlb.replacements           2068448 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0674 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0674 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              257044 # total first level page table misses
mem.ptab_accesses        1148873818 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 21:48:47 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 65 # total simulation time in seconds
sim_inst_rate          1538461.5538 # simulation speed (in insts/sec)
sim_total_insn            108007245 # total number of instructions executed
sim_total_refs             31907966 # total number of loads and stores executed
sim_total_loads            24657173 # total number of loads executed
sim_total_stores       7250793.0000 # total number of stores executed
sim_total_branches         22089060 # total number of branches executed
sim_cycle                1035100806 # total simulation time in cycles
sim_IPC                      0.0966 # instructions per cycle
sim_CPI                     10.3510 # cycles per instruction
sim_exec_BW                  0.1043 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4089099249 # cumulative IFQ occupancy
IFQ_fcount               1018186162 # cumulative IFQ full count
ifq_occupancy                3.9504 # avg IFQ occupancy (insn's)
ifq_rate                     0.1043 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 37.8595 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9837 # fraction of time (cycle's) IFQ was full
RUU_count               16342290474 # cumulative RUU occupancy
RUU_fcount               1004075429 # cumulative RUU full count
ruu_occupancy               15.7881 # avg RUU occupancy (insn's)
ruu_rate                     0.1043 # avg RUU dispatch rate (insn/cycle)
ruu_latency                151.3074 # avg RUU occupant latency (cycle's)
ruu_full                     0.9700 # fraction of time (cycle's) RUU was full
LSQ_count                8044260087 # cumulative LSQ occupancy
LSQ_fcount                985740162 # cumulative LSQ full count
lsq_occupancy                7.7715 # avg LSQ occupancy (insn's)
lsq_rate                     0.1043 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 74.4789 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9523 # fraction of time (cycle's) LSQ was full
sim_slip                24479868072 # total number of slip cycles
avg_sim_slip               244.7987 # the average slip between issue and retirement
bpred_2lev.lookups         22495875 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       19341032 # total number of address-predicted hits
bpred_2lev.dir_hits        19355850 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1295168 # total number of misses
bpred_2lev.jr_hits          1130124 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9366 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9373 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9872 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1351722 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1235514 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1127064 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9872 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              111600810 # total number of accesses
il1.hits                  110965063 # total number of hits
il1.misses                   635747 # total number of misses
il1.replacements             635425 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0057 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0057 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27259570 # total number of accesses
dl1.hits                   23901277 # total number of hits
dl1.misses                  3358293 # total number of misses
dl1.replacements            3357781 # total number of replacements
dl1.writebacks                43922 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1232 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1232 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4037962 # total number of accesses
ul2.hits                     694526 # total number of hits
ul2.misses                  3343436 # total number of misses
ul2.replacements            3340065 # total number of replacements
ul2.writebacks                27503 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8280 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8272 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             111600810 # total number of accesses
itlb.hits                 111600788 # total number of hits
itlb.misses                      22 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              30666227 # total number of accesses
dtlb.hits                  28597213 # total number of hits
dtlb.misses                 2069014 # total number of misses
dtlb.replacements           2068886 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0675 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0675 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              259106 # total first level page table misses
mem.ptab_accesses        1152422274 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 4 4 2 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 21:49:53 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      4 4 2 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 12 # total simulation time in seconds
sim_inst_rate          8333333.3333 # simulation speed (in insts/sec)
sim_total_insn            101415694 # total number of instructions executed
sim_total_refs             25667032 # total number of loads and stores executed
sim_total_loads            21856507 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2609370 # total number of branches executed
sim_cycle                  94994446 # total simulation time in cycles
sim_IPC                      1.0527 # instructions per cycle
sim_CPI                      0.9499 # cycles per instruction
sim_exec_BW                  1.0676 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 372173503 # cumulative IFQ occupancy
IFQ_fcount                 92161669 # cumulative IFQ full count
ifq_occupancy                3.9178 # avg IFQ occupancy (insn's)
ifq_rate                     1.0676 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.6698 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9702 # fraction of time (cycle's) IFQ was full
RUU_count                1465870305 # cumulative RUU occupancy
RUU_fcount                 80762787 # cumulative RUU full count
ruu_occupancy               15.4311 # avg RUU occupancy (insn's)
ruu_rate                     1.0676 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.4541 # avg RUU occupant latency (cycle's)
ruu_full                     0.8502 # fraction of time (cycle's) RUU was full
LSQ_count                 363374210 # cumulative LSQ occupancy
LSQ_fcount                  7535976 # cumulative LSQ full count
lsq_occupancy                3.8252 # avg LSQ occupancy (insn's)
lsq_rate                     1.0676 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.5830 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0793 # fraction of time (cycle's) LSQ was full
sim_slip                 1950893878 # total number of slip cycles
avg_sim_slip                19.5089 # the average slip between issue and retirement
bpred_2lev.lookups          2613950 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2178452 # total number of address-predicted hits
bpred_2lev.dir_hits         2178464 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            421979 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8377 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8377 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              103052317 # total number of accesses
il1.hits                  103052231 # total number of hits
il1.misses                       86 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24754017 # total number of accesses
dl1.hits                   24588270 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330695 # total number of accesses
ul2.hits                     246844 # total number of hits
ul2.misses                    83851 # total number of misses
ul2.replacements              79755 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             103052317 # total number of accesses
itlb.hits                 103052315 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24754056 # total number of accesses
dtlb.hits                  24752704 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1119786968 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 8 16 4 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 21:50:06 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      8 16 4 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 12 # total simulation time in seconds
sim_inst_rate          8333333.3333 # simulation speed (in insts/sec)
sim_total_insn            100375809 # total number of instructions executed
sim_total_refs             24905425 # total number of loads and stores executed
sim_total_loads            21094938 # total number of loads executed
sim_total_stores       3810487.0000 # total number of stores executed
sim_total_branches          2610333 # total number of branches executed
sim_cycle                  94729297 # total simulation time in cycles
sim_IPC                      1.0556 # instructions per cycle
sim_CPI                      0.9473 # cycles per instruction
sim_exec_BW                  1.0596 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 372987322 # cumulative IFQ occupancy
IFQ_fcount                 92650358 # cumulative IFQ full count
ifq_occupancy                3.9374 # avg IFQ occupancy (insn's)
ifq_rate                     1.0596 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7159 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9781 # fraction of time (cycle's) IFQ was full
RUU_count                1471823154 # cumulative RUU occupancy
RUU_fcount                 81858430 # cumulative RUU full count
ruu_occupancy               15.5371 # avg RUU occupancy (insn's)
ruu_rate                     1.0596 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.6631 # avg RUU occupant latency (cycle's)
ruu_full                     0.8641 # fraction of time (cycle's) RUU was full
LSQ_count                 360344099 # cumulative LSQ occupancy
LSQ_fcount                  7537287 # cumulative LSQ full count
lsq_occupancy                3.8039 # avg LSQ occupancy (insn's)
lsq_rate                     1.0596 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.5899 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0796 # fraction of time (cycle's) LSQ was full
sim_slip                 1955915018 # total number of slip cycles
avg_sim_slip                19.5592 # the average slip between issue and retirement
bpred_2lev.lookups          2615719 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2325998 # total number of address-predicted hits
bpred_2lev.dir_hits         2326006 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            274437 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8945 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8945 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              101464519 # total number of accesses
il1.hits                  101464431 # total number of hits
il1.misses                       88 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24760406 # total number of accesses
dl1.hits                   24594659 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330697 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83852 # total number of misses
ul2.replacements              79756 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             101464519 # total number of accesses
itlb.hits                 101464517 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24760445 # total number of accesses
dtlb.hits                  24759093 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1113543320 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 16 64 6 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 21:50:19 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      16 64 6 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 12 # total simulation time in seconds
sim_inst_rate          8333333.3333 # simulation speed (in insts/sec)
sim_total_insn            100128398 # total number of instructions executed
sim_total_refs             24807793 # total number of loads and stores executed
sim_total_loads            20997268 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2606106 # total number of branches executed
sim_cycle                  94697845 # total simulation time in cycles
sim_IPC                      1.0560 # instructions per cycle
sim_CPI                      0.9470 # cycles per instruction
sim_exec_BW                  1.0573 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 375232697 # cumulative IFQ occupancy
IFQ_fcount                 93178409 # cumulative IFQ full count
ifq_occupancy                3.9624 # avg IFQ occupancy (insn's)
ifq_rate                     1.0573 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7475 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9840 # fraction of time (cycle's) IFQ was full
RUU_count                1475159596 # cumulative RUU occupancy
RUU_fcount                 82848804 # cumulative RUU full count
ruu_occupancy               15.5775 # avg RUU occupancy (insn's)
ruu_rate                     1.0573 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.7327 # avg RUU occupant latency (cycle's)
ruu_full                     0.8749 # fraction of time (cycle's) RUU was full
LSQ_count                 361938798 # cumulative LSQ occupancy
LSQ_fcount                  7532827 # cumulative LSQ full count
lsq_occupancy                3.8220 # avg LSQ occupancy (insn's)
lsq_rate                     1.0573 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6147 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0795 # fraction of time (cycle's) LSQ was full
sim_slip                 1961587426 # total number of slip cycles
avg_sim_slip                19.6159 # the average slip between issue and retirement
bpred_2lev.lookups          2613917 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2551199 # total number of address-predicted hits
bpred_2lev.dir_hits         2551205 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses             49238 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9811 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9811 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              100316464 # total number of accesses
il1.hits                  100316375 # total number of hits
il1.misses                       89 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24754095 # total number of accesses
dl1.hits                   24588348 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330698 # total number of accesses
ul2.hits                     246844 # total number of hits
ul2.misses                    83854 # total number of misses
ul2.replacements              79758 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             100316464 # total number of accesses
itlb.hits                 100316462 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24754134 # total number of accesses
dtlb.hits                  24752782 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1110855848 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 256 8 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 21:50:32 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 256 8 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 12 # total simulation time in seconds
sim_inst_rate          8333333.3333 # simulation speed (in insts/sec)
sim_total_insn            100101505 # total number of instructions executed
sim_total_refs             24789921 # total number of loads and stores executed
sim_total_loads            20979396 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2604981 # total number of branches executed
sim_cycle                  94702074 # total simulation time in cycles
sim_IPC                      1.0559 # instructions per cycle
sim_CPI                      0.9470 # cycles per instruction
sim_exec_BW                  1.0570 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 375395447 # cumulative IFQ occupancy
IFQ_fcount                 93223004 # cumulative IFQ full count
ifq_occupancy                3.9640 # avg IFQ occupancy (insn's)
ifq_rate                     1.0570 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7501 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9844 # fraction of time (cycle's) IFQ was full
RUU_count                1475524321 # cumulative RUU occupancy
RUU_fcount                 82911272 # cumulative RUU full count
ruu_occupancy               15.5807 # avg RUU occupancy (insn's)
ruu_rate                     1.0570 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.7403 # avg RUU occupant latency (cycle's)
ruu_full                     0.8755 # fraction of time (cycle's) RUU was full
LSQ_count                 362043571 # cumulative LSQ occupancy
LSQ_fcount                  7537288 # cumulative LSQ full count
lsq_occupancy                3.8230 # avg LSQ occupancy (insn's)
lsq_rate                     1.0570 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6168 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0796 # fraction of time (cycle's) LSQ was full
sim_slip                 1962108553 # total number of slip cycles
avg_sim_slip                19.6211 # the average slip between issue and retirement
bpred_2lev.lookups          2609452 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2564589 # total number of address-predicted hits
bpred_2lev.dir_hits         2564601 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses             35842 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9862 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9862 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              100235992 # total number of accesses
il1.hits                  100235903 # total number of hits
il1.misses                       89 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24756318 # total number of accesses
dl1.hits                   24590571 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330698 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83853 # total number of misses
ul2.replacements              79757 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             100235992 # total number of accesses
itlb.hits                 100235990 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24756357 # total number of accesses
dtlb.hits                  24755005 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1110636828 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 64 1024 10 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 21:50:45 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      64 1024 10 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 12 # total simulation time in seconds
sim_inst_rate          8333333.3333 # simulation speed (in insts/sec)
sim_total_insn            100065493 # total number of instructions executed
sim_total_refs             24785425 # total number of loads and stores executed
sim_total_loads            20974900 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2602711 # total number of branches executed
sim_cycle                  94680642 # total simulation time in cycles
sim_IPC                      1.0562 # instructions per cycle
sim_CPI                      0.9468 # cycles per instruction
sim_exec_BW                  1.0569 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 375380419 # cumulative IFQ occupancy
IFQ_fcount                 93215060 # cumulative IFQ full count
ifq_occupancy                3.9647 # avg IFQ occupancy (insn's)
ifq_rate                     1.0569 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7513 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9845 # fraction of time (cycle's) IFQ was full
RUU_count                1475537041 # cumulative RUU occupancy
RUU_fcount                 82930207 # cumulative RUU full count
ruu_occupancy               15.5844 # avg RUU occupancy (insn's)
ruu_rate                     1.0569 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.7457 # avg RUU occupant latency (cycle's)
ruu_full                     0.8759 # fraction of time (cycle's) RUU was full
LSQ_count                 362026903 # cumulative LSQ occupancy
LSQ_fcount                  7546212 # cumulative LSQ full count
lsq_occupancy                3.8237 # avg LSQ occupancy (insn's)
lsq_rate                     1.0569 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6179 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0797 # fraction of time (cycle's) LSQ was full
sim_slip                 1962190388 # total number of slip cycles
avg_sim_slip                19.6219 # the average slip between issue and retirement
bpred_2lev.lookups          2607183 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2573548 # total number of address-predicted hits
bpred_2lev.dir_hits         2573560 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses             26883 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9897 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9897 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              100164144 # total number of accesses
il1.hits                  100164055 # total number of hits
il1.misses                       89 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24754047 # total number of accesses
dl1.hits                   24588300 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330698 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83853 # total number of misses
ul2.replacements              79757 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             100164144 # total number of accesses
itlb.hits                 100164142 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24754086 # total number of accesses
dtlb.hits                  24752734 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1110484082 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 21:50:58 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 12 # total simulation time in seconds
sim_inst_rate          8333333.3333 # simulation speed (in insts/sec)
sim_total_insn            100065474 # total number of instructions executed
sim_total_refs             24785420 # total number of loads and stores executed
sim_total_loads            20974895 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2602711 # total number of branches executed
sim_cycle                  94680628 # total simulation time in cycles
sim_IPC                      1.0562 # instructions per cycle
sim_CPI                      0.9468 # cycles per instruction
sim_exec_BW                  1.0569 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 375380357 # cumulative IFQ occupancy
IFQ_fcount                 93215047 # cumulative IFQ full count
ifq_occupancy                3.9647 # avg IFQ occupancy (insn's)
ifq_rate                     1.0569 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7513 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9845 # fraction of time (cycle's) IFQ was full
RUU_count                1475536992 # cumulative RUU occupancy
RUU_fcount                 82930200 # cumulative RUU full count
ruu_occupancy               15.5844 # avg RUU occupancy (insn's)
ruu_rate                     1.0569 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.7457 # avg RUU occupant latency (cycle's)
ruu_full                     0.8759 # fraction of time (cycle's) RUU was full
LSQ_count                 362026862 # cumulative LSQ occupancy
LSQ_fcount                  7546212 # cumulative LSQ full count
lsq_occupancy                3.8237 # avg LSQ occupancy (insn's)
lsq_rate                     1.0569 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6179 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0797 # fraction of time (cycle's) LSQ was full
sim_slip                 1962190355 # total number of slip cycles
avg_sim_slip                19.6219 # the average slip between issue and retirement
bpred_2lev.lookups          2607184 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2573548 # total number of address-predicted hits
bpred_2lev.dir_hits         2573560 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses             26883 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9897 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9897 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              100164125 # total number of accesses
il1.hits                  100164036 # total number of hits
il1.misses                       89 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24754046 # total number of accesses
dl1.hits                   24588299 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330698 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83853 # total number of misses
ul2.replacements              79757 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             100164125 # total number of accesses
itlb.hits                 100164123 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24754085 # total number of accesses
dtlb.hits                  24752733 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1110484028 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 4 4 2 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 21:51:11 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      4 4 2 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 24 # total simulation time in seconds
sim_inst_rate          4166666.7083 # simulation speed (in insts/sec)
sim_total_insn            111603847 # total number of instructions executed
sim_total_refs             51120958 # total number of loads and stores executed
sim_total_loads            30417401 # total number of loads executed
sim_total_stores       20703557.0000 # total number of stores executed
sim_total_branches         11771641 # total number of branches executed
sim_cycle                  84747073 # total simulation time in cycles
sim_IPC                      1.1800 # instructions per cycle
sim_CPI                      0.8475 # cycles per instruction
sim_exec_BW                  1.3169 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 172708724 # cumulative IFQ occupancy
IFQ_fcount                 38856621 # cumulative IFQ full count
ifq_occupancy                2.0379 # avg IFQ occupancy (insn's)
ifq_rate                     1.3169 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5475 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4585 # fraction of time (cycle's) IFQ was full
RUU_count                 635906398 # cumulative RUU occupancy
RUU_fcount                 10367957 # cumulative RUU full count
ruu_occupancy                7.5036 # avg RUU occupancy (insn's)
ruu_rate                     1.3169 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.6979 # avg RUU occupant latency (cycle's)
ruu_full                     0.1223 # fraction of time (cycle's) RUU was full
LSQ_count                 289910454 # cumulative LSQ occupancy
LSQ_fcount                 14258540 # cumulative LSQ full count
lsq_occupancy                3.4209 # avg LSQ occupancy (insn's)
lsq_rate                     1.3169 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.5977 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1682 # fraction of time (cycle's) LSQ was full
sim_slip                 1017682741 # total number of slip cycles
avg_sim_slip                10.1768 # the average slip between issue and retirement
bpred_2lev.lookups         12197642 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        7720168 # total number of address-predicted hits
bpred_2lev.dir_hits         7896818 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2440536 # total number of misses
bpred_2lev.jr_hits          1523274 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7468 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7639 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8962 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1320763 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1551960 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1181262 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9299 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              121939379 # total number of accesses
il1.hits                  116718638 # total number of hits
il1.misses                  5220741 # total number of misses
il1.replacements            5220338 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0428 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0428 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               47076261 # total number of accesses
dl1.hits                   46960585 # total number of hits
dl1.misses                   115676 # total number of misses
dl1.replacements             115164 # total number of replacements
dl1.writebacks                42632 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0024 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5379049 # total number of accesses
ul2.hits                    5376933 # total number of hits
ul2.misses                     2116 # total number of misses
ul2.replacements                768 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             121939379 # total number of accesses
itlb.hits                 121939343 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47459601 # total number of accesses
dtlb.hits                  47459549 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202338 # total first level page table misses
mem.ptab_accesses        1729140212 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 8 16 4 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 21:51:36 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      8 16 4 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 25 # total simulation time in seconds
sim_inst_rate          4000000.0400 # simulation speed (in insts/sec)
sim_total_insn            110913117 # total number of instructions executed
sim_total_refs             50496314 # total number of loads and stores executed
sim_total_loads            29970827 # total number of loads executed
sim_total_stores       20525487.0000 # total number of stores executed
sim_total_branches         11999496 # total number of branches executed
sim_cycle                  83516937 # total simulation time in cycles
sim_IPC                      1.1974 # instructions per cycle
sim_CPI                      0.8352 # cycles per instruction
sim_exec_BW                  1.3280 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 171662077 # cumulative IFQ occupancy
IFQ_fcount                 38586383 # cumulative IFQ full count
ifq_occupancy                2.0554 # avg IFQ occupancy (insn's)
ifq_rate                     1.3280 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5477 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4620 # fraction of time (cycle's) IFQ was full
RUU_count                 634100437 # cumulative RUU occupancy
RUU_fcount                 10667266 # cumulative RUU full count
ruu_occupancy                7.5925 # avg RUU occupancy (insn's)
ruu_rate                     1.3280 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.7171 # avg RUU occupant latency (cycle's)
ruu_full                     0.1277 # fraction of time (cycle's) RUU was full
LSQ_count                 287715204 # cumulative LSQ occupancy
LSQ_fcount                 14055938 # cumulative LSQ full count
lsq_occupancy                3.4450 # avg LSQ occupancy (insn's)
lsq_rate                     1.3280 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.5941 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1683 # fraction of time (cycle's) LSQ was full
sim_slip                 1019180798 # total number of slip cycles
avg_sim_slip                10.1918 # the average slip between issue and retirement
bpred_2lev.lookups         12458250 # total number of bpred lookups
bpred_2lev.updates         10337355 # total number of updates
bpred_2lev.addr_hits        7945820 # total number of address-predicted hits
bpred_2lev.dir_hits         8129251 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2208104 # total number of misses
bpred_2lev.jr_hits          1516507 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7687 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7864 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8922 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1323373 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1642679 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1174495 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9245 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              120992525 # total number of accesses
il1.hits                  115915383 # total number of hits
il1.misses                  5077142 # total number of misses
il1.replacements            5076739 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0420 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0420 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               46879383 # total number of accesses
dl1.hits                   46763917 # total number of hits
dl1.misses                   115466 # total number of misses
dl1.replacements             114954 # total number of replacements
dl1.writebacks                42609 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5235217 # total number of accesses
ul2.hits                    5233096 # total number of hits
ul2.misses                     2121 # total number of misses
ul2.replacements                772 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             120992525 # total number of accesses
itlb.hits                 120992489 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47319241 # total number of accesses
dtlb.hits                  47319189 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              205042 # total first level page table misses
mem.ptab_accesses        1725768514 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 16 64 6 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 21:52:02 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      16 64 6 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 24 # total simulation time in seconds
sim_inst_rate          4166666.7083 # simulation speed (in insts/sec)
sim_total_insn            109170675 # total number of instructions executed
sim_total_refs             50145759 # total number of loads and stores executed
sim_total_loads            29798589 # total number of loads executed
sim_total_stores       20347170.0000 # total number of stores executed
sim_total_branches         11665681 # total number of branches executed
sim_cycle                  80674471 # total simulation time in cycles
sim_IPC                      1.2395 # instructions per cycle
sim_CPI                      0.8067 # cycles per instruction
sim_exec_BW                  1.3532 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 170017999 # cumulative IFQ occupancy
IFQ_fcount                 38515763 # cumulative IFQ full count
ifq_occupancy                2.1075 # avg IFQ occupancy (insn's)
ifq_rate                     1.3532 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5574 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4774 # fraction of time (cycle's) IFQ was full
RUU_count                 634260967 # cumulative RUU occupancy
RUU_fcount                 10656869 # cumulative RUU full count
ruu_occupancy                7.8620 # avg RUU occupancy (insn's)
ruu_rate                     1.3532 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.8098 # avg RUU occupant latency (cycle's)
ruu_full                     0.1321 # fraction of time (cycle's) RUU was full
LSQ_count                 288693730 # cumulative LSQ occupancy
LSQ_fcount                 14498176 # cumulative LSQ full count
lsq_occupancy                3.5785 # avg LSQ occupancy (insn's)
lsq_rate                     1.3532 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.6444 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1797 # fraction of time (cycle's) LSQ was full
sim_slip                 1028278303 # total number of slip cycles
avg_sim_slip                10.2828 # the average slip between issue and retirement
bpred_2lev.lookups         12007206 # total number of bpred lookups
bpred_2lev.updates         10337355 # total number of updates
bpred_2lev.addr_hits        8368761 # total number of address-predicted hits
bpred_2lev.dir_hits         8555154 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1782201 # total number of misses
bpred_2lev.jr_hits          1513539 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8096 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8276 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8904 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1345566 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1659296 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1171527 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9222 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              118216987 # total number of accesses
il1.hits                  113161663 # total number of hits
il1.misses                  5055324 # total number of misses
il1.replacements            5054920 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0428 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0428 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               46582416 # total number of accesses
dl1.hits                   46467032 # total number of hits
dl1.misses                   115384 # total number of misses
dl1.replacements             114872 # total number of replacements
dl1.writebacks                42594 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5213302 # total number of accesses
ul2.hits                    5211300 # total number of hits
ul2.misses                     2002 # total number of misses
ul2.replacements                654 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             118216987 # total number of accesses
itlb.hits                 118216952 # total number of hits
itlb.misses                      35 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47011796 # total number of accesses
dtlb.hits                  47011746 # total number of hits
dtlb.misses                      50 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              206217 # total first level page table misses
mem.ptab_accesses        1719574598 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 256 8 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 21:52:27 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 256 8 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 24 # total simulation time in seconds
sim_inst_rate          4166666.6667 # simulation speed (in insts/sec)
sim_total_insn            105827888 # total number of instructions executed
sim_total_refs             48462752 # total number of loads and stores executed
sim_total_loads            28445001 # total number of loads executed
sim_total_stores       20017751.0000 # total number of stores executed
sim_total_branches         11119400 # total number of branches executed
sim_cycle                  77466654 # total simulation time in cycles
sim_IPC                      1.2909 # instructions per cycle
sim_CPI                      0.7747 # cycles per instruction
sim_exec_BW                  1.3661 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 166139235 # cumulative IFQ occupancy
IFQ_fcount                 37772167 # cumulative IFQ full count
ifq_occupancy                2.1447 # avg IFQ occupancy (insn's)
ifq_rate                     1.3661 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5699 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4876 # fraction of time (cycle's) IFQ was full
RUU_count                 628280991 # cumulative RUU occupancy
RUU_fcount                 11153166 # cumulative RUU full count
ruu_occupancy                8.1103 # avg RUU occupancy (insn's)
ruu_rate                     1.3661 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.9368 # avg RUU occupant latency (cycle's)
ruu_full                     0.1440 # fraction of time (cycle's) RUU was full
LSQ_count                 286256890 # cumulative LSQ occupancy
LSQ_fcount                 14640276 # cumulative LSQ full count
lsq_occupancy                3.6952 # avg LSQ occupancy (insn's)
lsq_rate                     1.3661 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.7049 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1890 # fraction of time (cycle's) LSQ was full
sim_slip                 1037130093 # total number of slip cycles
avg_sim_slip                10.3713 # the average slip between issue and retirement
bpred_2lev.lookups         11339528 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        9008550 # total number of address-predicted hits
bpred_2lev.dir_hits         9185320 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1152034 # total number of misses
bpred_2lev.jr_hits          1523146 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8715 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8886 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8961 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1301506 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1464754 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1181134 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9298 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              113333674 # total number of accesses
il1.hits                  108392554 # total number of hits
il1.misses                  4941120 # total number of misses
il1.replacements            4940714 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0436 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0436 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               46033701 # total number of accesses
dl1.hits                   45918190 # total number of hits
dl1.misses                   115511 # total number of misses
dl1.replacements             114999 # total number of replacements
dl1.writebacks                42595 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5099226 # total number of accesses
ul2.hits                    5097102 # total number of hits
ul2.misses                     2124 # total number of misses
ul2.replacements                772 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0002 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             113333674 # total number of accesses
itlb.hits                 113333637 # total number of hits
itlb.misses                      37 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              46490609 # total number of accesses
dtlb.hits                  46490557 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202389 # total first level page table misses
mem.ptab_accesses        1705464136 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 64 1024 10 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 21:52:52 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      64 1024 10 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 24 # total simulation time in seconds
sim_inst_rate          4166666.7083 # simulation speed (in insts/sec)
sim_total_insn            102869286 # total number of instructions executed
sim_total_refs             47119395 # total number of loads and stores executed
sim_total_loads            27360785 # total number of loads executed
sim_total_stores       19758610.0000 # total number of stores executed
sim_total_branches         10729894 # total number of branches executed
sim_cycle                  73846591 # total simulation time in cycles
sim_IPC                      1.3542 # instructions per cycle
sim_CPI                      0.7385 # cycles per instruction
sim_exec_BW                  1.3930 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 161416966 # cumulative IFQ occupancy
IFQ_fcount                 36682439 # cumulative IFQ full count
ifq_occupancy                2.1858 # avg IFQ occupancy (insn's)
ifq_rate                     1.3930 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5691 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4967 # fraction of time (cycle's) IFQ was full
RUU_count                 621654215 # cumulative RUU occupancy
RUU_fcount                 11108408 # cumulative RUU full count
ruu_occupancy                8.4182 # avg RUU occupancy (insn's)
ruu_rate                     1.3930 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  6.0431 # avg RUU occupant latency (cycle's)
ruu_full                     0.1504 # fraction of time (cycle's) RUU was full
LSQ_count                 283426640 # cumulative LSQ occupancy
LSQ_fcount                 14749869 # cumulative LSQ full count
lsq_occupancy                3.8380 # avg LSQ occupancy (insn's)
lsq_rate                     1.3930 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.7552 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1997 # fraction of time (cycle's) LSQ was full
sim_slip                 1040599571 # total number of slip cycles
avg_sim_slip                10.4060 # the average slip between issue and retirement
bpred_2lev.lookups         10870648 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        9664049 # total number of address-predicted hits
bpred_2lev.dir_hits         9840819 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            496535 # total number of misses
bpred_2lev.jr_hits          1523140 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9349 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9520 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8961 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1276893 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1364365 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1181128 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9298 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              109334612 # total number of accesses
il1.hits                  104440297 # total number of hits
il1.misses                  4894315 # total number of misses
il1.replacements            4893910 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0448 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0448 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               45572018 # total number of accesses
dl1.hits                   45456591 # total number of hits
dl1.misses                   115427 # total number of misses
dl1.replacements             114915 # total number of replacements
dl1.writebacks                42587 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5052329 # total number of accesses
ul2.hits                    5050607 # total number of hits
ul2.misses                     1722 # total number of misses
ul2.replacements                370 # total number of replacements
ul2.writebacks                   70 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0003 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             109334612 # total number of accesses
itlb.hits                 109334576 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              46039078 # total number of accesses
dtlb.hits                  46039026 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202301 # total first level page table misses
mem.ptab_accesses        1694253050 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 21:53:16 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 23 # total simulation time in seconds
sim_inst_rate          4347826.0870 # simulation speed (in insts/sec)
sim_total_insn            103562317 # total number of instructions executed
sim_total_refs             47397765 # total number of loads and stores executed
sim_total_loads            27635793 # total number of loads executed
sim_total_stores       19761972.0000 # total number of stores executed
sim_total_branches         10819468 # total number of branches executed
sim_cycle                  74724108 # total simulation time in cycles
sim_IPC                      1.3383 # instructions per cycle
sim_CPI                      0.7472 # cycles per instruction
sim_exec_BW                  1.3859 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 162577492 # cumulative IFQ occupancy
IFQ_fcount                 36971397 # cumulative IFQ full count
ifq_occupancy                2.1757 # avg IFQ occupancy (insn's)
ifq_rate                     1.3859 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5699 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4948 # fraction of time (cycle's) IFQ was full
RUU_count                 622918793 # cumulative RUU occupancy
RUU_fcount                 11219833 # cumulative RUU full count
ruu_occupancy                8.3362 # avg RUU occupancy (insn's)
ruu_rate                     1.3859 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  6.0149 # avg RUU occupant latency (cycle's)
ruu_full                     0.1502 # fraction of time (cycle's) RUU was full
LSQ_count                 283728107 # cumulative LSQ occupancy
LSQ_fcount                 14679378 # cumulative LSQ full count
lsq_occupancy                3.7970 # avg LSQ occupancy (insn's)
lsq_rate                     1.3859 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.7397 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1964 # fraction of time (cycle's) LSQ was full
sim_slip                 1040046242 # total number of slip cycles
avg_sim_slip                10.4005 # the average slip between issue and retirement
bpred_2lev.lookups         10961491 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        9514663 # total number of address-predicted hits
bpred_2lev.dir_hits         9691386 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            645968 # total number of misses
bpred_2lev.jr_hits          1523193 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9204 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9375 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8961 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1287572 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1402976 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1181181 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9298 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              110228291 # total number of accesses
il1.hits                  105369211 # total number of hits
il1.misses                  4859080 # total number of misses
il1.replacements            4858674 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0441 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0441 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               45598929 # total number of accesses
dl1.hits                   45483475 # total number of hits
dl1.misses                   115454 # total number of misses
dl1.replacements             114942 # total number of replacements
dl1.writebacks                42588 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5017122 # total number of accesses
ul2.hits                    5015251 # total number of hits
ul2.misses                     1871 # total number of misses
ul2.replacements                519 # total number of replacements
ul2.writebacks                   84 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             110228291 # total number of accesses
itlb.hits                 110228254 # total number of hits
itlb.misses                      37 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              46082136 # total number of accesses
dtlb.hits                  46082084 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202175 # total first level page table misses
mem.ptab_accesses        1696698994 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 4 4 2 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:53:40 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      4 4 2 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 23 # total simulation time in seconds
sim_inst_rate          4347826.1304 # simulation speed (in insts/sec)
sim_total_insn            118853180 # total number of instructions executed
sim_total_refs             39982488 # total number of loads and stores executed
sim_total_loads            30609156 # total number of loads executed
sim_total_stores       9373332.0000 # total number of stores executed
sim_total_branches         20476731 # total number of branches executed
sim_cycle                  79693451 # total simulation time in cycles
sim_IPC                      1.2548 # instructions per cycle
sim_CPI                      0.7969 # cycles per instruction
sim_exec_BW                  1.4914 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 150109754 # cumulative IFQ occupancy
IFQ_fcount                 31824352 # cumulative IFQ full count
ifq_occupancy                1.8836 # avg IFQ occupancy (insn's)
ifq_rate                     1.4914 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2630 # avg IFQ occupant latency (cycle's)
ifq_full                     0.3993 # fraction of time (cycle's) IFQ was full
RUU_count                 590088444 # cumulative RUU occupancy
RUU_fcount                 11788617 # cumulative RUU full count
ruu_occupancy                7.4045 # avg RUU occupancy (insn's)
ruu_rate                     1.4914 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  4.9649 # avg RUU occupant latency (cycle's)
ruu_full                     0.1479 # fraction of time (cycle's) RUU was full
LSQ_count                 201783775 # cumulative LSQ occupancy
LSQ_fcount                  2621549 # cumulative LSQ full count
lsq_occupancy                2.5320 # avg LSQ occupancy (insn's)
lsq_rate                     1.4914 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.6978 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0329 # fraction of time (cycle's) LSQ was full
sim_slip                  852682557 # total number of slip cycles
avg_sim_slip                 8.5268 # the average slip between issue and retirement
bpred_2lev.lookups         21562160 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       11329601 # total number of address-predicted hits
bpred_2lev.dir_hits        11447437 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5088252 # total number of misses
bpred_2lev.jr_hits          2620471 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6852 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6923 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9468 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3420778 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2978535 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2375254 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9528 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              125334124 # total number of accesses
il1.hits                  121907666 # total number of hits
il1.misses                  3426458 # total number of misses
il1.replacements            3426193 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0273 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0273 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36828692 # total number of accesses
dl1.hits                   36807226 # total number of hits
dl1.misses                    21466 # total number of misses
dl1.replacements              20954 # total number of replacements
dl1.writebacks                10839 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3458763 # total number of accesses
ul2.hits                    3451605 # total number of hits
ul2.misses                     7158 # total number of misses
ul2.replacements               3062 # total number of replacements
ul2.writebacks                 2563 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0021 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0007 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             125334124 # total number of accesses
itlb.hits                 125334108 # total number of hits
itlb.misses                      16 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36974776 # total number of accesses
dtlb.hits                  36974653 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8108170 # total first level page table misses
mem.ptab_accesses        1501287724 # total page table accesses
mem.ptab_miss_rate           0.0054 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 8 16 4 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:54:04 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      8 16 4 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 24 # total simulation time in seconds
sim_inst_rate          4166666.7083 # simulation speed (in insts/sec)
sim_total_insn            121409333 # total number of instructions executed
sim_total_refs             40056543 # total number of loads and stores executed
sim_total_loads            30598822 # total number of loads executed
sim_total_stores       9457721.0000 # total number of stores executed
sim_total_branches         20627167 # total number of branches executed
sim_cycle                  81806127 # total simulation time in cycles
sim_IPC                      1.2224 # instructions per cycle
sim_CPI                      0.8181 # cycles per instruction
sim_exec_BW                  1.4841 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 152857520 # cumulative IFQ occupancy
IFQ_fcount                 32592061 # cumulative IFQ full count
ifq_occupancy                1.8685 # avg IFQ occupancy (insn's)
ifq_rate                     1.4841 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2590 # avg IFQ occupant latency (cycle's)
ifq_full                     0.3984 # fraction of time (cycle's) IFQ was full
RUU_count                 597498940 # cumulative RUU occupancy
RUU_fcount                 12155050 # cumulative RUU full count
ruu_occupancy                7.3038 # avg RUU occupancy (insn's)
ruu_rate                     1.4841 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  4.9214 # avg RUU occupant latency (cycle's)
ruu_full                     0.1486 # fraction of time (cycle's) RUU was full
LSQ_count                 201862806 # cumulative LSQ occupancy
LSQ_fcount                  2633787 # cumulative LSQ full count
lsq_occupancy                2.4676 # avg LSQ occupancy (insn's)
lsq_rate                     1.4841 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.6627 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0322 # fraction of time (cycle's) LSQ was full
sim_slip                  844405590 # total number of slip cycles
avg_sim_slip                 8.4441 # the average slip between issue and retirement
bpred_2lev.lookups         21603795 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       11169389 # total number of address-predicted hits
bpred_2lev.dir_hits        11203688 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5332001 # total number of misses
bpred_2lev.jr_hits          2704007 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6755 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6775 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9770 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3500373 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      3074389 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2458790 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9863 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              126446347 # total number of accesses
il1.hits                  122886862 # total number of hits
il1.misses                  3559485 # total number of misses
il1.replacements            3559218 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0282 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0281 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               37069838 # total number of accesses
dl1.hits                   37048347 # total number of hits
dl1.misses                    21491 # total number of misses
dl1.replacements              20979 # total number of replacements
dl1.writebacks                10839 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3591815 # total number of accesses
ul2.hits                    3584652 # total number of hits
ul2.misses                     7163 # total number of misses
ul2.replacements               3067 # total number of replacements
ul2.writebacks                 2566 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0020 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0007 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             126446347 # total number of accesses
itlb.hits                 126446331 # total number of hits
itlb.misses                      16 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              37172415 # total number of accesses
dtlb.hits                  37172292 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             7985824 # total first level page table misses
mem.ptab_accesses        1503356088 # total page table accesses
mem.ptab_miss_rate           0.0053 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 16 64 6 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:54:29 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      16 64 6 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 23 # total simulation time in seconds
sim_inst_rate          4347826.1304 # simulation speed (in insts/sec)
sim_total_insn            116056648 # total number of instructions executed
sim_total_refs             39363790 # total number of loads and stores executed
sim_total_loads            30086253 # total number of loads executed
sim_total_stores       9277537.0000 # total number of stores executed
sim_total_branches         19484393 # total number of branches executed
sim_cycle                  73871115 # total simulation time in cycles
sim_IPC                      1.3537 # instructions per cycle
sim_CPI                      0.7387 # cycles per instruction
sim_exec_BW                  1.5711 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 149911343 # cumulative IFQ occupancy
IFQ_fcount                 32227902 # cumulative IFQ full count
ifq_occupancy                2.0294 # avg IFQ occupancy (insn's)
ifq_rate                     1.5711 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2917 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4363 # fraction of time (cycle's) IFQ was full
RUU_count                 590128322 # cumulative RUU occupancy
RUU_fcount                 14356937 # cumulative RUU full count
ruu_occupancy                7.9886 # avg RUU occupancy (insn's)
ruu_rate                     1.5711 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.0848 # avg RUU occupant latency (cycle's)
ruu_full                     0.1944 # fraction of time (cycle's) RUU was full
LSQ_count                 203637629 # cumulative LSQ occupancy
LSQ_fcount                  2951135 # cumulative LSQ full count
lsq_occupancy                2.7567 # avg LSQ occupancy (insn's)
lsq_rate                     1.5711 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.7546 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0399 # fraction of time (cycle's) LSQ was full
sim_slip                  860415807 # total number of slip cycles
avg_sim_slip                 8.6042 # the average slip between issue and retirement
bpred_2lev.lookups         20253037 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       12715475 # total number of address-predicted hits
bpred_2lev.dir_hits        12745954 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           3789735 # total number of misses
bpred_2lev.jr_hits          2707838 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7690 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7708 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9784 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3191902 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2685376 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2462621 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9878 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              121308213 # total number of accesses
il1.hits                  118013541 # total number of hits
il1.misses                  3294672 # total number of misses
il1.replacements            3294404 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0272 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0272 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36793760 # total number of accesses
dl1.hits                   36772262 # total number of hits
dl1.misses                    21498 # total number of misses
dl1.replacements              20986 # total number of replacements
dl1.writebacks                10841 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3327011 # total number of accesses
ul2.hits                    3319853 # total number of hits
ul2.misses                     7158 # total number of misses
ul2.replacements               3062 # total number of replacements
ul2.writebacks                 2563 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0022 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0008 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             121308213 # total number of accesses
itlb.hits                 121308196 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36939938 # total number of accesses
dtlb.hits                  36939815 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8048119 # total first level page table misses
mem.ptab_accesses        1491544326 # total page table accesses
mem.ptab_miss_rate           0.0054 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 256 8 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:54:53 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 256 8 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 23 # total simulation time in seconds
sim_inst_rate          4347826.1304 # simulation speed (in insts/sec)
sim_total_insn            113116346 # total number of instructions executed
sim_total_refs             38519577 # total number of loads and stores executed
sim_total_loads            29307264 # total number of loads executed
sim_total_stores       9212313.0000 # total number of stores executed
sim_total_branches         18879725 # total number of branches executed
sim_cycle                  69844109 # total simulation time in cycles
sim_IPC                      1.4318 # instructions per cycle
sim_CPI                      0.6984 # cycles per instruction
sim_exec_BW                  1.6196 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 147253427 # cumulative IFQ occupancy
IFQ_fcount                 31894010 # cumulative IFQ full count
ifq_occupancy                2.1083 # avg IFQ occupancy (insn's)
ifq_rate                     1.6196 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.3018 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4566 # fraction of time (cycle's) IFQ was full
RUU_count                 585090296 # cumulative RUU occupancy
RUU_fcount                 14984524 # cumulative RUU full count
ruu_occupancy                8.3771 # avg RUU occupancy (insn's)
ruu_rate                     1.6196 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.1725 # avg RUU occupant latency (cycle's)
ruu_full                     0.2145 # fraction of time (cycle's) RUU was full
LSQ_count                 205463915 # cumulative LSQ occupancy
LSQ_fcount                  3616922 # cumulative LSQ full count
lsq_occupancy                2.9418 # avg LSQ occupancy (insn's)
lsq_rate                     1.6196 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.8164 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0518 # fraction of time (cycle's) LSQ was full
sim_slip                  870844578 # total number of slip cycles
avg_sim_slip                 8.7084 # the average slip between issue and retirement
bpred_2lev.lookups         19582808 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       13567364 # total number of address-predicted hits
bpred_2lev.dir_hits        13571686 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2964003 # total number of misses
bpred_2lev.jr_hits          2733980 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8205 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8208 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9878 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      2913029 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2743151 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2488763 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9983 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              118547102 # total number of accesses
il1.hits                  115236349 # total number of hits
il1.misses                  3310753 # total number of misses
il1.replacements            3310484 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0279 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0279 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36547710 # total number of accesses
dl1.hits                   36526236 # total number of hits
dl1.misses                    21474 # total number of misses
dl1.replacements              20962 # total number of replacements
dl1.writebacks                10840 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3343067 # total number of accesses
ul2.hits                    3335904 # total number of hits
ul2.misses                     7163 # total number of misses
ul2.replacements               3067 # total number of replacements
ul2.writebacks                 2567 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0021 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0008 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             118547102 # total number of accesses
itlb.hits                 118547085 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36701439 # total number of accesses
dtlb.hits                  36701316 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             7838377 # total first level page table misses
mem.ptab_accesses        1483000456 # total page table accesses
mem.ptab_miss_rate           0.0053 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 64 1024 10 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:55:17 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      64 1024 10 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 21 # total simulation time in seconds
sim_inst_rate          4761904.8095 # simulation speed (in insts/sec)
sim_total_insn            107269972 # total number of instructions executed
sim_total_refs             37192372 # total number of loads and stores executed
sim_total_loads            28349007 # total number of loads executed
sim_total_stores       8843365.0000 # total number of stores executed
sim_total_branches         17908874 # total number of branches executed
sim_cycle                  63480711 # total simulation time in cycles
sim_IPC                      1.5753 # instructions per cycle
sim_CPI                      0.6348 # cycles per instruction
sim_exec_BW                  1.6898 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 141161393 # cumulative IFQ occupancy
IFQ_fcount                 30543438 # cumulative IFQ full count
ifq_occupancy                2.2237 # avg IFQ occupancy (insn's)
ifq_rate                     1.6898 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.3159 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4811 # fraction of time (cycle's) IFQ was full
RUU_count                 575830792 # cumulative RUU occupancy
RUU_fcount                 15737068 # cumulative RUU full count
ruu_occupancy                9.0710 # avg RUU occupancy (insn's)
ruu_rate                     1.6898 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.3681 # avg RUU occupant latency (cycle's)
ruu_full                     0.2479 # fraction of time (cycle's) RUU was full
LSQ_count                 204303589 # cumulative LSQ occupancy
LSQ_fcount                  3786167 # cumulative LSQ full count
lsq_occupancy                3.2184 # avg LSQ occupancy (insn's)
lsq_rate                     1.6898 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.9046 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0596 # fraction of time (cycle's) LSQ was full
sim_slip                  884785341 # total number of slip cycles
avg_sim_slip                 8.8479 # the average slip between issue and retirement
bpred_2lev.lookups         18376596 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       14908809 # total number of address-predicted hits
bpred_2lev.dir_hits        14934621 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1601068 # total number of misses
bpred_2lev.jr_hits          2712490 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9016 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9032 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9801 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      2716490 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2587011 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2467273 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9897 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              112774783 # total number of accesses
il1.hits                  109486286 # total number of hits
il1.misses                  3288497 # total number of misses
il1.replacements            3288230 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0292 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0292 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36030583 # total number of accesses
dl1.hits                   36009105 # total number of hits
dl1.misses                    21478 # total number of misses
dl1.replacements              20966 # total number of replacements
dl1.writebacks                10841 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3320816 # total number of accesses
ul2.hits                    3313657 # total number of hits
ul2.misses                     7159 # total number of misses
ul2.replacements               3063 # total number of replacements
ul2.writebacks                 2564 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0022 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0008 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             112774783 # total number of accesses
itlb.hits                 112774766 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36138616 # total number of accesses
dtlb.hits                  36138493 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             7774377 # total first level page table misses
mem.ptab_accesses        1468390946 # total page table accesses
mem.ptab_miss_rate           0.0053 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:55:39 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 22 # total simulation time in seconds
sim_inst_rate          4545454.5909 # simulation speed (in insts/sec)
sim_total_insn            107100512 # total number of instructions executed
sim_total_refs             37020763 # total number of loads and stores executed
sim_total_loads            28216723 # total number of loads executed
sim_total_stores       8804040.0000 # total number of stores executed
sim_total_branches         17798677 # total number of branches executed
sim_cycle                  62952986 # total simulation time in cycles
sim_IPC                      1.5885 # instructions per cycle
sim_CPI                      0.6295 # cycles per instruction
sim_exec_BW                  1.7013 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 140052402 # cumulative IFQ occupancy
IFQ_fcount                 30188466 # cumulative IFQ full count
ifq_occupancy                2.2247 # avg IFQ occupancy (insn's)
ifq_rate                     1.7013 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.3077 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4795 # fraction of time (cycle's) IFQ was full
RUU_count                 573953136 # cumulative RUU occupancy
RUU_fcount                 15612603 # cumulative RUU full count
ruu_occupancy                9.1172 # avg RUU occupancy (insn's)
ruu_rate                     1.7013 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.3590 # avg RUU occupant latency (cycle's)
ruu_full                     0.2480 # fraction of time (cycle's) RUU was full
LSQ_count                 202830346 # cumulative LSQ occupancy
LSQ_fcount                  3777081 # cumulative LSQ full count
lsq_occupancy                3.2219 # avg LSQ occupancy (insn's)
lsq_rate                     1.7013 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.8938 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0600 # fraction of time (cycle's) LSQ was full
sim_slip                  881983339 # total number of slip cycles
avg_sim_slip                 8.8198 # the average slip between issue and retirement
bpred_2lev.lookups         18206538 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       14856069 # total number of address-predicted hits
bpred_2lev.dir_hits        14865763 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1669926 # total number of misses
bpred_2lev.jr_hits          2728613 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8984 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8990 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9859 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      2745138 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2662795 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2483396 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9962 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              111180866 # total number of accesses
il1.hits                  107990042 # total number of hits
il1.misses                  3190824 # total number of misses
il1.replacements            3190555 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0287 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0287 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               35965064 # total number of accesses
dl1.hits                   35943579 # total number of hits
dl1.misses                    21485 # total number of misses
dl1.replacements              20973 # total number of replacements
dl1.writebacks                10840 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3223149 # total number of accesses
ul2.hits                    3215988 # total number of hits
ul2.misses                     7161 # total number of misses
ul2.replacements               3065 # total number of replacements
ul2.writebacks                 2565 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0022 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0010 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0008 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             111180866 # total number of accesses
itlb.hits                 111180849 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36107359 # total number of accesses
dtlb.hits                  36107236 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             7706217 # total first level page table misses
mem.ptab_accesses        1464721000 # total page table accesses
mem.ptab_miss_rate           0.0053 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 4 4 2 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:56:02 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      4 4 2 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 22 # total simulation time in seconds
sim_inst_rate          4545454.6364 # simulation speed (in insts/sec)
sim_total_insn            136160079 # total number of instructions executed
sim_total_refs             32140908 # total number of loads and stores executed
sim_total_loads            26454971 # total number of loads executed
sim_total_stores       5685937.0000 # total number of stores executed
sim_total_branches         27502125 # total number of branches executed
sim_cycle                 106536708 # total simulation time in cycles
sim_IPC                      0.9386 # instructions per cycle
sim_CPI                      1.0654 # cycles per instruction
sim_exec_BW                  1.2781 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 284415324 # cumulative IFQ occupancy
IFQ_fcount                 63990854 # cumulative IFQ full count
ifq_occupancy                2.6696 # avg IFQ occupancy (insn's)
ifq_rate                     1.2781 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.0888 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6006 # fraction of time (cycle's) IFQ was full
RUU_count                1061097478 # cumulative RUU occupancy
RUU_fcount                 40429067 # cumulative RUU full count
ruu_occupancy                9.9599 # avg RUU occupancy (insn's)
ruu_rate                     1.2781 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  7.7930 # avg RUU occupant latency (cycle's)
ruu_full                     0.3795 # fraction of time (cycle's) RUU was full
LSQ_count                 277839444 # cumulative LSQ occupancy
LSQ_fcount                  4342497 # cumulative LSQ full count
lsq_occupancy                2.6079 # avg LSQ occupancy (insn's)
lsq_rate                     1.2781 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.0405 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0408 # fraction of time (cycle's) LSQ was full
sim_slip                 1273763061 # total number of slip cycles
avg_sim_slip                12.7376 # the average slip between issue and retirement
bpred_2lev.lookups         30356898 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       13865863 # total number of address-predicted hits
bpred_2lev.dir_hits        14228987 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5473643 # total number of misses
bpred_2lev.jr_hits          1046378 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7038 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7222 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.7425 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      2089542 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      4057719 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1032724 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.7400 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              150333747 # total number of accesses
il1.hits                  148765301 # total number of hits
il1.misses                  1568446 # total number of misses
il1.replacements            1567991 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0104 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0104 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               26056741 # total number of accesses
dl1.hits                   25676942 # total number of hits
dl1.misses                   379799 # total number of misses
dl1.replacements             379287 # total number of replacements
dl1.writebacks               118797 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0146 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0146 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0046 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2067042 # total number of accesses
ul2.hits                    1944061 # total number of hits
ul2.misses                   122981 # total number of misses
ul2.replacements             118885 # total number of replacements
ul2.writebacks                47982 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0595 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0575 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0232 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             150333747 # total number of accesses
itlb.hits                 150333716 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              26154480 # total number of accesses
dtlb.hits                  26132531 # total number of hits
dtlb.misses                   21949 # total number of misses
dtlb.replacements             21821 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0008 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              252798 # total first level page table misses
mem.ptab_accesses        1089333940 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 8 16 4 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:56:25 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      8 16 4 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 21 # total simulation time in seconds
sim_inst_rate          4761904.8571 # simulation speed (in insts/sec)
sim_total_insn            129974227 # total number of instructions executed
sim_total_refs             30477774 # total number of loads and stores executed
sim_total_loads            25309824 # total number of loads executed
sim_total_stores       5167950.0000 # total number of stores executed
sim_total_branches         25739245 # total number of branches executed
sim_cycle                  98224623 # total simulation time in cycles
sim_IPC                      1.0181 # instructions per cycle
sim_CPI                      0.9822 # cycles per instruction
sim_exec_BW                  1.3232 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 276925097 # cumulative IFQ occupancy
IFQ_fcount                 62401649 # cumulative IFQ full count
ifq_occupancy                2.8193 # avg IFQ occupancy (insn's)
ifq_rate                     1.3232 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1306 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6353 # fraction of time (cycle's) IFQ was full
RUU_count                1037975882 # cumulative RUU occupancy
RUU_fcount                 42235240 # cumulative RUU full count
ruu_occupancy               10.5674 # avg RUU occupancy (insn's)
ruu_rate                     1.3232 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  7.9860 # avg RUU occupant latency (cycle's)
ruu_full                     0.4300 # fraction of time (cycle's) RUU was full
LSQ_count                 273063683 # cumulative LSQ occupancy
LSQ_fcount                  4368478 # cumulative LSQ full count
lsq_occupancy                2.7800 # avg LSQ occupancy (insn's)
lsq_rate                     1.3232 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.1009 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0445 # fraction of time (cycle's) LSQ was full
sim_slip                 1293724950 # total number of slip cycles
avg_sim_slip                12.9372 # the average slip between issue and retirement
bpred_2lev.lookups         27737978 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       15168729 # total number of address-predicted hits
bpred_2lev.dir_hits        15430917 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           4271713 # total number of misses
bpred_2lev.jr_hits          1147309 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7699 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7832 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8142 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1851330 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2393823 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1133655 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.8124 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              142485719 # total number of accesses
il1.hits                  140903613 # total number of hits
il1.misses                  1582106 # total number of misses
il1.replacements            1581650 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0111 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0111 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               25442944 # total number of accesses
dl1.hits                   25068388 # total number of hits
dl1.misses                   374556 # total number of misses
dl1.replacements             374044 # total number of replacements
dl1.writebacks               118379 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0147 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0147 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0047 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2075041 # total number of accesses
ul2.hits                    1954081 # total number of hits
ul2.misses                   120960 # total number of misses
ul2.replacements             116864 # total number of replacements
ul2.writebacks                47858 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0583 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0563 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0231 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             142485719 # total number of accesses
itlb.hits                 142485688 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              25540003 # total number of accesses
dtlb.hits                  25518213 # total number of hits
dtlb.misses                   21790 # total number of misses
dtlb.replacements             21662 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0009 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              251044 # total first level page table misses
mem.ptab_accesses        1069723680 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 16 64 6 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:56:47 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      16 64 6 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 22 # total simulation time in seconds
sim_inst_rate          4545454.6364 # simulation speed (in insts/sec)
sim_total_insn            129988646 # total number of instructions executed
sim_total_refs             30276650 # total number of loads and stores executed
sim_total_loads            25219635 # total number of loads executed
sim_total_stores       5057015.0000 # total number of stores executed
sim_total_branches         25735349 # total number of branches executed
sim_cycle                  98738493 # total simulation time in cycles
sim_IPC                      1.0128 # instructions per cycle
sim_CPI                      0.9874 # cycles per instruction
sim_exec_BW                  1.3165 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 277861027 # cumulative IFQ occupancy
IFQ_fcount                 62612300 # cumulative IFQ full count
ifq_occupancy                2.8141 # avg IFQ occupancy (insn's)
ifq_rate                     1.3165 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1376 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6341 # fraction of time (cycle's) IFQ was full
RUU_count                1041270236 # cumulative RUU occupancy
RUU_fcount                 42646346 # cumulative RUU full count
ruu_occupancy               10.5457 # avg RUU occupancy (insn's)
ruu_rate                     1.3165 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  8.0105 # avg RUU occupant latency (cycle's)
ruu_full                     0.4319 # fraction of time (cycle's) RUU was full
LSQ_count                 274581825 # cumulative LSQ occupancy
LSQ_fcount                  4552475 # cumulative LSQ full count
lsq_occupancy                2.7809 # avg LSQ occupancy (insn's)
lsq_rate                     1.3165 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.1124 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0461 # fraction of time (cycle's) LSQ was full
sim_slip                 1314600207 # total number of slip cycles
avg_sim_slip                13.1460 # the average slip between issue and retirement
bpred_2lev.lookups         27780840 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       15292064 # total number of address-predicted hits
bpred_2lev.dir_hits        15475151 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           4227479 # total number of misses
bpred_2lev.jr_hits          1226392 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7761 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7854 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8703 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1874919 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2393085 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1212738 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.8690 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              142227663 # total number of accesses
il1.hits                  140541811 # total number of hits
il1.misses                  1685852 # total number of misses
il1.replacements            1685395 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0119 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0118 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               25532093 # total number of accesses
dl1.hits                   25155128 # total number of hits
dl1.misses                   376965 # total number of misses
dl1.replacements             376453 # total number of replacements
dl1.writebacks               118758 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0148 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0147 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0047 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2181575 # total number of accesses
ul2.hits                    2060139 # total number of hits
ul2.misses                   121436 # total number of misses
ul2.replacements             117340 # total number of replacements
ul2.writebacks                47890 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0557 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0538 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0220 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             142227663 # total number of accesses
itlb.hits                 142227632 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              25610656 # total number of accesses
dtlb.hits                  25588664 # total number of hits
dtlb.misses                   21992 # total number of misses
dtlb.replacements             21864 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0009 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0009 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              250214 # total first level page table misses
mem.ptab_accesses        1068955732 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 256 8 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:57:10 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 256 8 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 20 # total simulation time in seconds
sim_inst_rate          5000000.1000 # simulation speed (in insts/sec)
sim_total_insn            123989355 # total number of instructions executed
sim_total_refs             28512920 # total number of loads and stores executed
sim_total_loads            23611754 # total number of loads executed
sim_total_stores       4901166.0000 # total number of stores executed
sim_total_branches         24273653 # total number of branches executed
sim_cycle                  92152703 # total simulation time in cycles
sim_IPC                      1.0852 # instructions per cycle
sim_CPI                      0.9215 # cycles per instruction
sim_exec_BW                  1.3455 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 270442954 # cumulative IFQ occupancy
IFQ_fcount                 61074075 # cumulative IFQ full count
ifq_occupancy                2.9347 # avg IFQ occupancy (insn's)
ifq_rate                     1.3455 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1812 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6627 # fraction of time (cycle's) IFQ was full
RUU_count                1025641790 # cumulative RUU occupancy
RUU_fcount                 43241388 # cumulative RUU full count
ruu_occupancy               11.1298 # avg RUU occupancy (insn's)
ruu_rate                     1.3455 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  8.2720 # avg RUU occupant latency (cycle's)
ruu_full                     0.4692 # fraction of time (cycle's) RUU was full
LSQ_count                 270201434 # cumulative LSQ occupancy
LSQ_fcount                  4465103 # cumulative LSQ full count
lsq_occupancy                2.9321 # avg LSQ occupancy (insn's)
lsq_rate                     1.3455 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.1792 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0485 # fraction of time (cycle's) LSQ was full
sim_slip                 1327054155 # total number of slip cycles
avg_sim_slip                13.2705 # the average slip between issue and retirement
bpred_2lev.lookups         25927536 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       16467255 # total number of address-predicted hits
bpred_2lev.dir_hits        16647369 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           3055261 # total number of misses
bpred_2lev.jr_hits          1229378 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8358 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8449 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8724 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1778612 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2039292 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1215724 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.8712 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              134285415 # total number of accesses
il1.hits                  132637791 # total number of hits
il1.misses                  1647624 # total number of misses
il1.replacements            1647172 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0123 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0123 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24855552 # total number of accesses
dl1.hits                   24482583 # total number of hits
dl1.misses                   372969 # total number of misses
dl1.replacements             372457 # total number of replacements
dl1.writebacks               118320 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0150 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0150 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0048 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2138913 # total number of accesses
ul2.hits                    2019516 # total number of hits
ul2.misses                   119397 # total number of misses
ul2.replacements             115301 # total number of replacements
ul2.writebacks                47769 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0558 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0539 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0223 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             134285415 # total number of accesses
itlb.hits                 134285384 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24973602 # total number of accesses
dtlb.hits                  24951602 # total number of hits
dtlb.misses                   22000 # total number of misses
dtlb.replacements             21872 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0009 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0009 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              252252 # total first level page table misses
mem.ptab_accesses        1047323102 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 64 1024 10 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:57:31 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      64 1024 10 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 19 # total simulation time in seconds
sim_inst_rate          5263158.0000 # simulation speed (in insts/sec)
sim_total_insn            119199837 # total number of instructions executed
sim_total_refs             27401373 # total number of loads and stores executed
sim_total_loads            22726801 # total number of loads executed
sim_total_stores       4674572.0000 # total number of stores executed
sim_total_branches         23274634 # total number of branches executed
sim_cycle                  87248104 # total simulation time in cycles
sim_IPC                      1.1462 # instructions per cycle
sim_CPI                      0.8725 # cycles per instruction
sim_exec_BW                  1.3662 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 264484438 # cumulative IFQ occupancy
IFQ_fcount                 59948758 # cumulative IFQ full count
ifq_occupancy                3.0314 # avg IFQ occupancy (insn's)
ifq_rate                     1.3662 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.2188 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6871 # fraction of time (cycle's) IFQ was full
RUU_count                1016808076 # cumulative RUU occupancy
RUU_fcount                 44369385 # cumulative RUU full count
ruu_occupancy               11.6542 # avg RUU occupancy (insn's)
ruu_rate                     1.3662 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  8.5303 # avg RUU occupant latency (cycle's)
ruu_full                     0.5085 # fraction of time (cycle's) RUU was full
LSQ_count                 267954715 # cumulative LSQ occupancy
LSQ_fcount                  4341863 # cumulative LSQ full count
lsq_occupancy                3.0712 # avg LSQ occupancy (insn's)
lsq_rate                     1.3662 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.2479 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0498 # fraction of time (cycle's) LSQ was full
sim_slip                 1335224310 # total number of slip cycles
avg_sim_slip                13.3522 # the average slip between issue and retirement
bpred_2lev.lookups         24647807 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       17336720 # total number of address-predicted hits
bpred_2lev.dir_hits        17416383 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2286247 # total number of misses
bpred_2lev.jr_hits          1329819 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8799 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8840 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9437 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1684965 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1793168 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1316165 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9431 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              127568235 # total number of accesses
il1.hits                  125940581 # total number of hits
il1.misses                  1627654 # total number of misses
il1.replacements            1627201 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0128 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0128 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24529267 # total number of accesses
dl1.hits                   24158415 # total number of hits
dl1.misses                   370852 # total number of misses
dl1.replacements             370340 # total number of replacements
dl1.writebacks               118101 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0151 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0151 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0048 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2116607 # total number of accesses
ul2.hits                    1998232 # total number of hits
ul2.misses                   118375 # total number of misses
ul2.replacements             114279 # total number of replacements
ul2.writebacks                47731 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0559 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0540 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0226 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             127568235 # total number of accesses
itlb.hits                 127568204 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24672872 # total number of accesses
dtlb.hits                  24650990 # total number of hits
dtlb.misses                   21882 # total number of misses
dtlb.replacements             21754 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0009 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0009 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              251300 # total first level page table misses
mem.ptab_accesses        1030590070 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 32 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:57:51 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      32 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 20 # total simulation time in seconds
sim_inst_rate          5000000.1000 # simulation speed (in insts/sec)
sim_total_insn            120828878 # total number of instructions executed
sim_total_refs             27717708 # total number of loads and stores executed
sim_total_loads            22926193 # total number of loads executed
sim_total_stores       4791515.0000 # total number of stores executed
sim_total_branches         23553090 # total number of branches executed
sim_cycle                  88752086 # total simulation time in cycles
sim_IPC                      1.1267 # instructions per cycle
sim_CPI                      0.8875 # cycles per instruction
sim_exec_BW                  1.3614 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 266574717 # cumulative IFQ occupancy
IFQ_fcount                 60372699 # cumulative IFQ full count
ifq_occupancy                3.0036 # avg IFQ occupancy (insn's)
ifq_rate                     1.3614 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.2062 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6802 # fraction of time (cycle's) IFQ was full
RUU_count                1019590070 # cumulative RUU occupancy
RUU_fcount                 43617046 # cumulative RUU full count
ruu_occupancy               11.4881 # avg RUU occupancy (insn's)
ruu_rate                     1.3614 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  8.4383 # avg RUU occupant latency (cycle's)
ruu_full                     0.4914 # fraction of time (cycle's) RUU was full
LSQ_count                 268247151 # cumulative LSQ occupancy
LSQ_fcount                  4486673 # cumulative LSQ full count
lsq_occupancy                3.0224 # avg LSQ occupancy (insn's)
lsq_rate                     1.3614 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.2201 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0506 # fraction of time (cycle's) LSQ was full
sim_slip                 1332524086 # total number of slip cycles
avg_sim_slip                13.3252 # the average slip between issue and retirement
bpred_2lev.lookups         24997888 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       17045772 # total number of address-predicted hits
bpred_2lev.dir_hits        17159028 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2543602 # total number of misses
bpred_2lev.jr_hits          1296243 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8652 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8709 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9199 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1666533 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1846944 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1282589 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9191 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              129929724 # total number of accesses
il1.hits                  128311126 # total number of hits
il1.misses                  1618598 # total number of misses
il1.replacements            1618145 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0125 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0125 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24583371 # total number of accesses
dl1.hits                   24209828 # total number of hits
dl1.misses                   373543 # total number of misses
dl1.replacements             373031 # total number of replacements
dl1.writebacks               118370 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0152 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0152 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0048 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2110511 # total number of accesses
ul2.hits                    1991007 # total number of hits
ul2.misses                   119504 # total number of misses
ul2.replacements             115408 # total number of replacements
ul2.writebacks                47791 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0566 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0547 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0226 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             129929724 # total number of accesses
itlb.hits                 129929693 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24720087 # total number of accesses
dtlb.hits                  24698144 # total number of hits
dtlb.misses                   21943 # total number of misses
dtlb.replacements             21815 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0009 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0009 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              250952 # total first level page table misses
mem.ptab_accesses        1036266026 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

