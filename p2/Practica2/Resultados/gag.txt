sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 8 3 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 20:46:43 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 8 3 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                144 # total simulation time in seconds
sim_inst_rate           694444.4514 # simulation speed (in insts/sec)
sim_total_insn            118192351 # total number of instructions executed
sim_total_refs             34536485 # total number of loads and stores executed
sim_total_loads            26731591 # total number of loads executed
sim_total_stores       7804894.0000 # total number of stores executed
sim_total_branches         24248559 # total number of branches executed
sim_cycle                1052317570 # total simulation time in cycles
sim_IPC                      0.0950 # instructions per cycle
sim_CPI                     10.5232 # cycles per instruction
sim_exec_BW                  0.1123 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4066481656 # cumulative IFQ occupancy
IFQ_fcount               1007636840 # cumulative IFQ full count
ifq_occupancy                3.8643 # avg IFQ occupancy (insn's)
ifq_rate                     0.1123 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 34.4056 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9575 # fraction of time (cycle's) IFQ was full
RUU_count               16378660334 # cumulative RUU occupancy
RUU_fcount                989280144 # cumulative RUU full count
ruu_occupancy               15.5644 # avg RUU occupancy (insn's)
ruu_rate                     0.1123 # avg RUU dispatch rate (insn/cycle)
ruu_latency                138.5763 # avg RUU occupant latency (cycle's)
ruu_full                     0.9401 # fraction of time (cycle's) RUU was full
LSQ_count                8041821331 # cumulative LSQ occupancy
LSQ_fcount                968582061 # cumulative LSQ full count
lsq_occupancy                7.6420 # avg LSQ occupancy (insn's)
lsq_rate                     0.1123 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 68.0401 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9204 # fraction of time (cycle's) LSQ was full
sim_slip                24322130317 # total number of slip cycles
avg_sim_slip               243.2213 # the average slip between issue and retirement
bpred_2lev.lookups         25332960 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       13650305 # total number of address-predicted hits
bpred_2lev.dir_hits        13695778 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           6955240 # total number of misses
bpred_2lev.jr_hits          1099487 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6610 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6632 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9604 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1519968 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1429792 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1096427 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9603 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              124930842 # total number of accesses
il1.hits                  124296691 # total number of hits
il1.misses                   634151 # total number of misses
il1.replacements             633830 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0051 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0051 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               28131402 # total number of accesses
dl1.hits                   24774294 # total number of hits
dl1.misses                  3357108 # total number of misses
dl1.replacements            3356596 # total number of replacements
dl1.writebacks                43888 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1193 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1193 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4035147 # total number of accesses
ul2.hits                     693635 # total number of hits
ul2.misses                  3341512 # total number of misses
ul2.replacements            3338140 # total number of replacements
ul2.writebacks                27460 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8281 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8273 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             124930842 # total number of accesses
itlb.hits                 124930822 # total number of hits
itlb.misses                      20 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              31537606 # total number of accesses
dtlb.hits                  29468675 # total number of hits
dtlb.misses                 2068931 # total number of misses
dtlb.replacements           2068803 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0656 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0656 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              254550 # total first level page table misses
mem.ptab_accesses        1186658866 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 32 5 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 20:49:07 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 32 5 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                146 # total simulation time in seconds
sim_inst_rate           684931.5137 # simulation speed (in insts/sec)
sim_total_insn            118729035 # total number of instructions executed
sim_total_refs             35235315 # total number of loads and stores executed
sim_total_loads            26863492 # total number of loads executed
sim_total_stores       8371823.0000 # total number of stores executed
sim_total_branches         24137074 # total number of branches executed
sim_cycle                1051756625 # total simulation time in cycles
sim_IPC                      0.0951 # instructions per cycle
sim_CPI                     10.5176 # cycles per instruction
sim_exec_BW                  0.1129 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4070972252 # cumulative IFQ occupancy
IFQ_fcount               1009225015 # cumulative IFQ full count
ifq_occupancy                3.8706 # avg IFQ occupancy (insn's)
ifq_rate                     0.1129 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 34.2879 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9596 # fraction of time (cycle's) IFQ was full
RUU_count               16388690591 # cumulative RUU occupancy
RUU_fcount                992258530 # cumulative RUU full count
ruu_occupancy               15.5822 # avg RUU occupancy (insn's)
ruu_rate                     0.1129 # avg RUU dispatch rate (insn/cycle)
ruu_latency                138.0344 # avg RUU occupant latency (cycle's)
ruu_full                     0.9434 # fraction of time (cycle's) RUU was full
LSQ_count                8047681412 # cumulative LSQ occupancy
LSQ_fcount                969643544 # cumulative LSQ full count
lsq_occupancy                7.6517 # avg LSQ occupancy (insn's)
lsq_rate                     0.1129 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 67.7819 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9219 # fraction of time (cycle's) LSQ was full
sim_slip                24336731274 # total number of slip cycles
avg_sim_slip               243.3673 # the average slip between issue and retirement
bpred_2lev.lookups         25226255 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       14068850 # total number of address-predicted hits
bpred_2lev.dir_hits        14103959 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           6547059 # total number of misses
bpred_2lev.jr_hits          1109848 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6813 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6830 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9695 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1520716 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1312088 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1106788 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9694 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              125202189 # total number of accesses
il1.hits                  124566171 # total number of hits
il1.misses                   636018 # total number of misses
il1.replacements             635697 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0051 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0051 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               28187542 # total number of accesses
dl1.hits                   24830300 # total number of hits
dl1.misses                  3357242 # total number of misses
dl1.replacements            3356730 # total number of replacements
dl1.writebacks                43916 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1191 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1191 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4037176 # total number of accesses
ul2.hits                     695595 # total number of hits
ul2.misses                  3341581 # total number of misses
ul2.replacements            3338208 # total number of replacements
ul2.writebacks                27513 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8277 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8269 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             125202189 # total number of accesses
itlb.hits                 125202168 # total number of hits
itlb.misses                      21 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              31602444 # total number of accesses
dtlb.hits                  29533488 # total number of hits
dtlb.misses                 2068956 # total number of misses
dtlb.replacements           2068828 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0655 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0655 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              257357 # total first level page table misses
mem.ptab_accesses        1187972816 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 128 7 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 20:51:33 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 128 7 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                115 # total simulation time in seconds
sim_inst_rate           869565.2261 # simulation speed (in insts/sec)
sim_total_insn            118651888 # total number of instructions executed
sim_total_refs             35392067 # total number of loads and stores executed
sim_total_loads            26892022 # total number of loads executed
sim_total_stores       8500045.0000 # total number of stores executed
sim_total_branches         24103892 # total number of branches executed
sim_cycle                1051423236 # total simulation time in cycles
sim_IPC                      0.0951 # instructions per cycle
sim_CPI                     10.5142 # cycles per instruction
sim_exec_BW                  0.1128 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4074875315 # cumulative IFQ occupancy
IFQ_fcount               1010220168 # cumulative IFQ full count
ifq_occupancy                3.8756 # avg IFQ occupancy (insn's)
ifq_rate                     0.1128 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 34.3431 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9608 # fraction of time (cycle's) IFQ was full
RUU_count               16396286900 # cumulative RUU occupancy
RUU_fcount                993281043 # cumulative RUU full count
ruu_occupancy               15.5944 # avg RUU occupancy (insn's)
ruu_rate                     0.1128 # avg RUU dispatch rate (insn/cycle)
ruu_latency                138.1882 # avg RUU occupant latency (cycle's)
ruu_full                     0.9447 # fraction of time (cycle's) RUU was full
LSQ_count                8008821607 # cumulative LSQ occupancy
LSQ_fcount                928921750 # cumulative LSQ full count
lsq_occupancy                7.6171 # avg LSQ occupancy (insn's)
lsq_rate                     0.1128 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 67.4985 # avg LSQ occupant latency (cycle's)
lsq_full                     0.8835 # fraction of time (cycle's) LSQ was full
sim_slip                23769127269 # total number of slip cycles
avg_sim_slip               237.6913 # the average slip between issue and retirement
bpred_2lev.lookups         25207851 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       14353016 # total number of address-predicted hits
bpred_2lev.dir_hits        14390529 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           6260489 # total number of misses
bpred_2lev.jr_hits          1107439 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6950 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6968 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9674 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1517403 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1318183 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1104379 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9673 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              125710187 # total number of accesses
il1.hits                  125071402 # total number of hits
il1.misses                   638785 # total number of misses
il1.replacements             638463 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0051 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0051 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               28498639 # total number of accesses
dl1.hits                   25141662 # total number of hits
dl1.misses                  3356977 # total number of misses
dl1.replacements            3356465 # total number of replacements
dl1.writebacks                43896 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1178 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1178 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0015 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4039658 # total number of accesses
ul2.hits                     698130 # total number of hits
ul2.misses                  3341528 # total number of misses
ul2.replacements            3338155 # total number of replacements
ul2.writebacks                27461 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8272 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8263 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             125710187 # total number of accesses
itlb.hits                 125710166 # total number of hits
itlb.misses                      21 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              31909872 # total number of accesses
dtlb.hits                  29840950 # total number of hits
dtlb.misses                 2068922 # total number of misses
dtlb.replacements           2068794 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0648 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0648 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              255770 # total first level page table misses
mem.ptab_accesses        1188965180 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 512 9 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 20:53:28 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 512 9 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 75 # total simulation time in seconds
sim_inst_rate          1333333.3467 # simulation speed (in insts/sec)
sim_total_insn            115077850 # total number of instructions executed
sim_total_refs             34365766 # total number of loads and stores executed
sim_total_loads            25981487 # total number of loads executed
sim_total_stores       8384279.0000 # total number of stores executed
sim_total_branches         23405005 # total number of branches executed
sim_cycle                1048734805 # total simulation time in cycles
sim_IPC                      0.0954 # instructions per cycle
sim_CPI                     10.4873 # cycles per instruction
sim_exec_BW                  0.1097 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4067299459 # cumulative IFQ occupancy
IFQ_fcount               1008395336 # cumulative IFQ full count
ifq_occupancy                3.8783 # avg IFQ occupancy (insn's)
ifq_rate                     0.1097 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 35.3439 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9615 # fraction of time (cycle's) IFQ was full
RUU_count               16382781446 # cumulative RUU occupancy
RUU_fcount                992666427 # cumulative RUU full count
ruu_occupancy               15.6215 # avg RUU occupancy (insn's)
ruu_rate                     0.1097 # avg RUU dispatch rate (insn/cycle)
ruu_latency                142.3626 # avg RUU occupant latency (cycle's)
ruu_full                     0.9465 # fraction of time (cycle's) RUU was full
LSQ_count                8037027536 # cumulative LSQ occupancy
LSQ_fcount                962993304 # cumulative LSQ full count
lsq_occupancy                7.6635 # avg LSQ occupancy (insn's)
lsq_rate                     0.1097 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 69.8399 # avg LSQ occupant latency (cycle's)
lsq_full                     0.9182 # fraction of time (cycle's) LSQ was full
sim_slip                24248735373 # total number of slip cycles
avg_sim_slip               242.4874 # the average slip between issue and retirement
bpred_2lev.lookups         24224423 # total number of bpred lookups
bpred_2lev.updates         20651018 # total number of updates
bpred_2lev.addr_hits       14652754 # total number of address-predicted hits
bpred_2lev.dir_hits        14676678 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5974340 # total number of misses
bpred_2lev.jr_hits          1121036 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7095 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7107 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9793 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1492698 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1236928 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1117976 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9792 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              120610479 # total number of accesses
il1.hits                  119980474 # total number of hits
il1.misses                   630005 # total number of misses
il1.replacements             629680 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0052 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0052 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27860614 # total number of accesses
dl1.hits                   24503767 # total number of hits
dl1.misses                  3356847 # total number of misses
dl1.replacements            3356335 # total number of replacements
dl1.writebacks                43893 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1205 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.1205 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0016 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4030745 # total number of accesses
ul2.hits                     689247 # total number of hits
ul2.misses                  3341498 # total number of misses
ul2.replacements            3338124 # total number of replacements
ul2.writebacks                27469 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8290 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8282 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             120610479 # total number of accesses
itlb.hits                 120610458 # total number of hits
itlb.misses                      21 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              31264995 # total number of accesses
dtlb.hits                  29196196 # total number of hits
dtlb.misses                 2068799 # total number of misses
dtlb.replacements           2068671 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0662 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0662 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              253302 # total first level page table misses
mem.ptab_accesses        1175653240 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/ammp.exe 

sim: simulation started @ Fri Oct 25 20:54:43 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               30101334 # total number of loads and stores committed
sim_num_loads              23145477 # total number of loads committed
sim_num_stores         6955857.0000 # total number of stores committed
sim_num_branches           20651019 # total number of branches committed
sim_elapsed_time                 73 # total simulation time in seconds
sim_inst_rate          1369863.0274 # simulation speed (in insts/sec)
sim_total_insn            141902952 # total number of instructions executed
sim_total_refs             45058580 # total number of loads and stores executed
sim_total_loads            33961160 # total number of loads executed
sim_total_stores       11097420.0000 # total number of stores executed
sim_total_branches         28735724 # total number of branches executed
sim_cycle                1072526824 # total simulation time in cycles
sim_IPC                      0.0932 # instructions per cycle
sim_CPI                     10.7253 # cycles per instruction
sim_exec_BW                  0.1323 # total instructions (mis-spec + committed) per cycle
sim_IPB                      4.8424 # instruction per branch
IFQ_count                4173418624 # cumulative IFQ occupancy
IFQ_fcount               1035625700 # cumulative IFQ full count
ifq_occupancy                3.8912 # avg IFQ occupancy (insn's)
ifq_rate                     0.1323 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                 29.4104 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9656 # fraction of time (cycle's) IFQ was full
RUU_count               16600170867 # cumulative RUU occupancy
RUU_fcount               1011923840 # cumulative RUU full count
ruu_occupancy               15.4776 # avg RUU occupancy (insn's)
ruu_rate                     0.1323 # avg RUU dispatch rate (insn/cycle)
ruu_latency                116.9826 # avg RUU occupant latency (cycle's)
ruu_full                     0.9435 # fraction of time (cycle's) RUU was full
LSQ_count                7319055155 # cumulative LSQ occupancy
LSQ_fcount                157737118 # cumulative LSQ full count
lsq_occupancy                6.8241 # avg LSQ occupancy (insn's)
lsq_rate                     0.1323 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                 51.5779 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1471 # fraction of time (cycle's) LSQ was full
sim_slip                13000821271 # total number of slip cycles
avg_sim_slip               130.0082 # the average slip between issue and retirement
bpred_2lev.lookups         32210089 # total number of bpred lookups
bpred_2lev.updates         20651017 # total number of updates
bpred_2lev.addr_hits       14790172 # total number of address-predicted hits
bpred_2lev.dir_hits        14812177 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5838840 # total number of misses
bpred_2lev.jr_hits          1122952 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1144770 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP         3060 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP         3065 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7162 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7173 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9809 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9984 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1478847 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1228235 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1141705 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1119892 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9809 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              158127932 # total number of accesses
il1.hits                  157498753 # total number of hits
il1.misses                   629179 # total number of misses
il1.replacements             628857 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0040 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0040 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               35932657 # total number of accesses
dl1.hits                   32576164 # total number of hits
dl1.misses                  3356493 # total number of misses
dl1.replacements            3355981 # total number of replacements
dl1.writebacks                43877 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0934 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0934 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0012 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                4029549 # total number of accesses
ul2.hits                     687722 # total number of hits
ul2.misses                  3341827 # total number of misses
ul2.replacements            3338455 # total number of replacements
ul2.writebacks                27471 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.8293 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.8285 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0068 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             158127932 # total number of accesses
itlb.hits                 158127912 # total number of hits
itlb.misses                      20 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              39337380 # total number of accesses
dtlb.hits                  37268806 # total number of hits
dtlb.misses                 2068574 # total number of misses
dtlb.replacements           2068446 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0526 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0526 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 368640 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83584 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120013040 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 1809 # total number of pages allocated
mem.page_mem                 14472k # total size of memory pages allocated
mem.ptab_misses              253856 # total first level page table misses
mem.ptab_accesses        1277244206 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 8 3 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 20:55:56 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 8 3 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 16 # total simulation time in seconds
sim_inst_rate          6250000.0000 # simulation speed (in insts/sec)
sim_total_insn            101444721 # total number of instructions executed
sim_total_refs             25673730 # total number of loads and stores executed
sim_total_loads            21863205 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2611603 # total number of branches executed
sim_cycle                  95009473 # total simulation time in cycles
sim_IPC                      1.0525 # instructions per cycle
sim_CPI                      0.9501 # cycles per instruction
sim_exec_BW                  1.0677 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 372169473 # cumulative IFQ occupancy
IFQ_fcount                 92162864 # cumulative IFQ full count
ifq_occupancy                3.9172 # avg IFQ occupancy (insn's)
ifq_rate                     1.0677 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.6687 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9700 # fraction of time (cycle's) IFQ was full
RUU_count                1465868798 # cumulative RUU occupancy
RUU_fcount                 80742976 # cumulative RUU full count
ruu_occupancy               15.4287 # avg RUU occupancy (insn's)
ruu_rate                     1.0677 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.4499 # avg RUU occupant latency (cycle's)
ruu_full                     0.8498 # fraction of time (cycle's) RUU was full
LSQ_count                 363311951 # cumulative LSQ occupancy
LSQ_fcount                  7531513 # cumulative LSQ full count
lsq_occupancy                3.8240 # avg LSQ occupancy (insn's)
lsq_rate                     1.0677 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.5814 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0793 # fraction of time (cycle's) LSQ was full
sim_slip                 1950785447 # total number of slip cycles
avg_sim_slip                19.5079 # the average slip between issue and retirement
bpred_2lev.lookups          2616106 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2171793 # total number of address-predicted hits
bpred_2lev.dir_hits         2171802 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            428641 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8352 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8352 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              103114517 # total number of accesses
il1.hits                  103114431 # total number of hits
il1.misses                       86 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24756249 # total number of accesses
dl1.hits                   24590502 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330695 # total number of accesses
ul2.hits                     246844 # total number of hits
ul2.misses                    83851 # total number of misses
ul2.replacements              79755 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             103114517 # total number of accesses
itlb.hits                 103114515 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24756288 # total number of accesses
dtlb.hits                  24754936 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1119929232 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 32 5 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 20:56:12 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 32 5 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 17 # total simulation time in seconds
sim_inst_rate          5882352.9412 # simulation speed (in insts/sec)
sim_total_insn            100637832 # total number of instructions executed
sim_total_refs             25168161 # total number of loads and stores executed
sim_total_loads            21357636 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2608256 # total number of branches executed
sim_cycle                  94728006 # total simulation time in cycles
sim_IPC                      1.0557 # instructions per cycle
sim_CPI                      0.9473 # cycles per instruction
sim_exec_BW                  1.0624 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 373832766 # cumulative IFQ occupancy
IFQ_fcount                 92714343 # cumulative IFQ full count
ifq_occupancy                3.9464 # avg IFQ occupancy (insn's)
ifq_rate                     1.0624 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7146 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9787 # fraction of time (cycle's) IFQ was full
RUU_count                1471317828 # cumulative RUU occupancy
RUU_fcount                 82128156 # cumulative RUU full count
ruu_occupancy               15.5320 # avg RUU occupancy (insn's)
ruu_rate                     1.0624 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.6199 # avg RUU occupant latency (cycle's)
ruu_full                     0.8670 # fraction of time (cycle's) RUU was full
LSQ_count                 362249608 # cumulative LSQ occupancy
LSQ_fcount                  7524779 # cumulative LSQ full count
lsq_occupancy                3.8241 # avg LSQ occupancy (insn's)
lsq_rate                     1.0624 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.5995 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0794 # fraction of time (cycle's) LSQ was full
sim_slip                 1957155278 # total number of slip cycles
avg_sim_slip                19.5716 # the average slip between issue and retirement
bpred_2lev.lookups          2612760 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2425128 # total number of address-predicted hits
bpred_2lev.dir_hits         2425135 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            175308 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9326 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9326 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              101294438 # total number of accesses
il1.hits                  101294352 # total number of hits
il1.misses                       86 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24759600 # total number of accesses
dl1.hits                   24593853 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330695 # total number of accesses
ul2.hits                     246844 # total number of hits
ul2.misses                    83851 # total number of misses
ul2.replacements              79755 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             101294438 # total number of accesses
itlb.hits                 101294436 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24759639 # total number of accesses
dtlb.hits                  24758287 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1114260100 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 128 7 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 20:56:29 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 128 7 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 16 # total simulation time in seconds
sim_inst_rate          6250000.0000 # simulation speed (in insts/sec)
sim_total_insn            100444791 # total number of instructions executed
sim_total_refs             25046367 # total number of loads and stores executed
sim_total_loads            21235842 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2609415 # total number of branches executed
sim_cycle                  94721604 # total simulation time in cycles
sim_IPC                      1.0557 # instructions per cycle
sim_CPI                      0.9472 # cycles per instruction
sim_exec_BW                  1.0604 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 374097644 # cumulative IFQ occupancy
IFQ_fcount                 92851758 # cumulative IFQ full count
ifq_occupancy                3.9494 # avg IFQ occupancy (insn's)
ifq_rate                     1.0604 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7244 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9803 # fraction of time (cycle's) IFQ was full
RUU_count                1472344980 # cumulative RUU occupancy
RUU_fcount                 82282370 # cumulative RUU full count
ruu_occupancy               15.5439 # avg RUU occupancy (insn's)
ruu_rate                     1.0604 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.6583 # avg RUU occupant latency (cycle's)
ruu_full                     0.8687 # fraction of time (cycle's) RUU was full
LSQ_count                 362206172 # cumulative LSQ occupancy
LSQ_fcount                  7527049 # cumulative LSQ full count
lsq_occupancy                3.8239 # avg LSQ occupancy (insn's)
lsq_rate                     1.0604 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6060 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0795 # fraction of time (cycle's) LSQ was full
sim_slip                 1958366472 # total number of slip cycles
avg_sim_slip                19.5837 # the average slip between issue and retirement
bpred_2lev.lookups          2613959 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2435206 # total number of address-predicted hits
bpred_2lev.dir_hits         2435211 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            165232 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9365 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9365 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              101070014 # total number of accesses
il1.hits                  101069926 # total number of hits
il1.misses                       88 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24758525 # total number of accesses
dl1.hits                   24592778 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330697 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83852 # total number of misses
ul2.replacements              79756 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             101070014 # total number of accesses
itlb.hits                 101070012 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24758564 # total number of accesses
dtlb.hits                  24757212 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1113328456 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 512 9 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 20:56:45 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 512 9 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 18 # total simulation time in seconds
sim_inst_rate          5555555.5556 # simulation speed (in insts/sec)
sim_total_insn            100445367 # total number of instructions executed
sim_total_refs             25046606 # total number of loads and stores executed
sim_total_loads            21236081 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2609457 # total number of branches executed
sim_cycle                  94721852 # total simulation time in cycles
sim_IPC                      1.0557 # instructions per cycle
sim_CPI                      0.9472 # cycles per instruction
sim_exec_BW                  1.0604 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 374098012 # cumulative IFQ occupancy
IFQ_fcount                 92851803 # cumulative IFQ full count
ifq_occupancy                3.9494 # avg IFQ occupancy (insn's)
ifq_rate                     1.0604 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7244 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9803 # fraction of time (cycle's) IFQ was full
RUU_count                1472345192 # cumulative RUU occupancy
RUU_fcount                 82282245 # cumulative RUU full count
ruu_occupancy               15.5439 # avg RUU occupancy (insn's)
ruu_rate                     1.0604 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.6582 # avg RUU occupant latency (cycle's)
ruu_full                     0.8687 # fraction of time (cycle's) RUU was full
LSQ_count                 362206357 # cumulative LSQ occupancy
LSQ_fcount                  7527049 # cumulative LSQ full count
lsq_occupancy                3.8239 # avg LSQ occupancy (insn's)
lsq_rate                     1.0604 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6060 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0795 # fraction of time (cycle's) LSQ was full
sim_slip                 1958365582 # total number of slip cycles
avg_sim_slip                19.5837 # the average slip between issue and retirement
bpred_2lev.lookups          2613962 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2435164 # total number of address-predicted hits
bpred_2lev.dir_hits         2435167 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            165276 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9364 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9364 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              101070766 # total number of accesses
il1.hits                  101070677 # total number of hits
il1.misses                       89 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24758527 # total number of accesses
dl1.hits                   24592780 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330698 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83853 # total number of misses
ul2.replacements              79757 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             101070766 # total number of accesses
itlb.hits                 101070764 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24758566 # total number of accesses
dtlb.hits                  24757214 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1113330910 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/applu.exe 

sim: simulation started @ Fri Oct 25 20:57:03 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
warning: partially supported sigaction() call...
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000000 # total number of instructions committed
sim_num_refs               24753981 # total number of loads and stores committed
sim_num_loads              20943495 # total number of loads committed
sim_num_stores         3810486.0000 # total number of stores committed
sim_num_branches            2600444 # total number of branches committed
sim_elapsed_time                 17 # total simulation time in seconds
sim_inst_rate          5882352.9412 # simulation speed (in insts/sec)
sim_total_insn            100469927 # total number of instructions executed
sim_total_refs             25053308 # total number of loads and stores executed
sim_total_loads            21242783 # total number of loads executed
sim_total_stores       3810525.0000 # total number of stores executed
sim_total_branches          2611689 # total number of branches executed
sim_cycle                  94744177 # total simulation time in cycles
sim_IPC                      1.0555 # instructions per cycle
sim_CPI                      0.9474 # cycles per instruction
sim_exec_BW                  1.0604 # total instructions (mis-spec + committed) per cycle
sim_IPB                     38.4550 # instruction per branch
IFQ_count                 374148197 # cumulative IFQ occupancy
IFQ_fcount                 92864070 # cumulative IFQ full count
ifq_occupancy                3.9490 # avg IFQ occupancy (insn's)
ifq_rate                     1.0604 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  3.7240 # avg IFQ occupant latency (cycle's)
ifq_full                     0.9802 # fraction of time (cycle's) IFQ was full
RUU_count                1472367433 # cumulative RUU occupancy
RUU_fcount                 82281112 # cumulative RUU full count
ruu_occupancy               15.5405 # avg RUU occupancy (insn's)
ruu_rate                     1.0604 # avg RUU dispatch rate (insn/cycle)
ruu_latency                 14.6548 # avg RUU occupant latency (cycle's)
ruu_full                     0.8685 # fraction of time (cycle's) RUU was full
LSQ_count                 362240953 # cumulative LSQ occupancy
LSQ_fcount                  7527049 # cumulative LSQ full count
lsq_occupancy                3.8234 # avg LSQ occupancy (insn's)
lsq_rate                     1.0604 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  3.6055 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0794 # fraction of time (cycle's) LSQ was full
sim_slip                 1958355439 # total number of slip cycles
avg_sim_slip                19.5836 # the average slip between issue and retirement
bpred_2lev.lookups          2615078 # total number of bpred lookups
bpred_2lev.updates          2600443 # total number of updates
bpred_2lev.addr_hits        2431812 # total number of address-predicted hits
bpred_2lev.dir_hits         2431815 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses            168628 # total number of misses
bpred_2lev.jr_hits                0 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen                0 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.9352 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.9352 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate <error: divide by zero> # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes            0 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops            0 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP            0 # total number of RAS predictions used
bpred_2lev.ras_hits.PP            0 # total number of RAS hits
bpred_2lev.ras_rate.PP <error: divide by zero> # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              101104266 # total number of accesses
il1.hits                  101104177 # total number of hits
il1.misses                       89 # total number of misses
il1.replacements                  0 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0000 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               24761875 # total number of accesses
dl1.hits                   24596128 # total number of hits
dl1.misses                   165747 # total number of misses
dl1.replacements             165235 # total number of replacements
dl1.writebacks               164862 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0067 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0067 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0067 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                 330698 # total number of accesses
ul2.hits                     246845 # total number of hits
ul2.misses                    83853 # total number of misses
ul2.replacements              79757 # total number of replacements
ul2.writebacks                79618 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.2536 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.2412 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.2408 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             101104266 # total number of accesses
itlb.hits                 101104264 # total number of hits
itlb.misses                       2 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              24761914 # total number of accesses
dtlb.hits                  24760562 # total number of hits
dtlb.misses                    1352 # total number of misses
dtlb.replacements              1224 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0001 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 286720 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size              198820592 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000ac40 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                 2162 # total number of pages allocated
mem.page_mem                 17296k # total size of memory pages allocated
mem.ptab_misses                2541 # total first level page table misses
mem.ptab_accesses        1113420254 # total page table accesses
mem.ptab_miss_rate           0.0000 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 8 3 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 20:57:20 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 8 3 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 30 # total simulation time in seconds
sim_inst_rate          3333333.3667 # simulation speed (in insts/sec)
sim_total_insn            111100229 # total number of instructions executed
sim_total_refs             51101062 # total number of loads and stores executed
sim_total_loads            30374881 # total number of loads executed
sim_total_stores       20726181.0000 # total number of stores executed
sim_total_branches         11751031 # total number of branches executed
sim_cycle                  84408566 # total simulation time in cycles
sim_IPC                      1.1847 # instructions per cycle
sim_CPI                      0.8441 # cycles per instruction
sim_exec_BW                  1.3162 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 172925689 # cumulative IFQ occupancy
IFQ_fcount                 39022054 # cumulative IFQ full count
ifq_occupancy                2.0487 # avg IFQ occupancy (insn's)
ifq_rate                     1.3162 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5565 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4623 # fraction of time (cycle's) IFQ was full
RUU_count                 632732574 # cumulative RUU occupancy
RUU_fcount                 10073502 # cumulative RUU full count
ruu_occupancy                7.4961 # avg RUU occupancy (insn's)
ruu_rate                     1.3162 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.6952 # avg RUU occupant latency (cycle's)
ruu_full                     0.1193 # fraction of time (cycle's) RUU was full
LSQ_count                 290816188 # cumulative LSQ occupancy
LSQ_fcount                 14987503 # cumulative LSQ full count
lsq_occupancy                3.4453 # avg LSQ occupancy (insn's)
lsq_rate                     1.3162 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.6176 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1776 # fraction of time (cycle's) LSQ was full
sim_slip                 1017189021 # total number of slip cycles
avg_sim_slip                10.1719 # the average slip between issue and retirement
bpred_2lev.lookups         12123562 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        7821798 # total number of address-predicted hits
bpred_2lev.dir_hits         7998570 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2338784 # total number of misses
bpred_2lev.jr_hits          1523160 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7567 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7738 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8961 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1348823 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1518295 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1181148 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9298 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              121486016 # total number of accesses
il1.hits                  116301025 # total number of hits
il1.misses                  5184991 # total number of misses
il1.replacements            5184587 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0427 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0427 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               47229356 # total number of accesses
dl1.hits                   47113671 # total number of hits
dl1.misses                   115685 # total number of misses
dl1.replacements             115173 # total number of replacements
dl1.writebacks                42616 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0024 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0024 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5343292 # total number of accesses
ul2.hits                    5341282 # total number of hits
ul2.misses                     2010 # total number of misses
ul2.replacements                661 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             121486016 # total number of accesses
itlb.hits                 121485981 # total number of hits
itlb.misses                      35 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47595255 # total number of accesses
dtlb.hits                  47595203 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202370 # total first level page table misses
mem.ptab_accesses        1728204712 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 32 5 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 20:57:50 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 32 5 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 28 # total simulation time in seconds
sim_inst_rate          3571428.6071 # simulation speed (in insts/sec)
sim_total_insn            109962718 # total number of instructions executed
sim_total_refs             50939771 # total number of loads and stores executed
sim_total_loads            30508647 # total number of loads executed
sim_total_stores       20431124.0000 # total number of stores executed
sim_total_branches         11571190 # total number of branches executed
sim_cycle                  82703551 # total simulation time in cycles
sim_IPC                      1.2091 # instructions per cycle
sim_CPI                      0.8270 # cycles per instruction
sim_exec_BW                  1.3296 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 170767481 # cumulative IFQ occupancy
IFQ_fcount                 38588215 # cumulative IFQ full count
ifq_occupancy                2.0648 # avg IFQ occupancy (insn's)
ifq_rate                     1.3296 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5530 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4666 # fraction of time (cycle's) IFQ was full
RUU_count                 629338132 # cumulative RUU occupancy
RUU_fcount                  9828810 # cumulative RUU full count
ruu_occupancy                7.6096 # avg RUU occupancy (insn's)
ruu_rate                     1.3296 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.7232 # avg RUU occupant latency (cycle's)
ruu_full                     0.1188 # fraction of time (cycle's) RUU was full
LSQ_count                 289176445 # cumulative LSQ occupancy
LSQ_fcount                 14890305 # cumulative LSQ full count
lsq_occupancy                3.4965 # avg LSQ occupancy (insn's)
lsq_rate                     1.3296 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.6298 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1800 # fraction of time (cycle's) LSQ was full
sim_slip                 1019162038 # total number of slip cycles
avg_sim_slip                10.1916 # the average slip between issue and retirement
bpred_2lev.lookups         11855694 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        8032351 # total number of address-predicted hits
bpred_2lev.dir_hits         8209181 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2128173 # total number of misses
bpred_2lev.jr_hits          1523101 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7770 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7941 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8961 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1345689 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1566101 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1181089 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9297 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              119809712 # total number of accesses
il1.hits                  114680785 # total number of hits
il1.misses                  5128927 # total number of misses
il1.replacements            5128523 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0428 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0428 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               47016622 # total number of accesses
dl1.hits                   46901143 # total number of hits
dl1.misses                   115479 # total number of misses
dl1.replacements             114967 # total number of replacements
dl1.writebacks                42602 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0024 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5287008 # total number of accesses
ul2.hits                    5284886 # total number of hits
ul2.misses                     2122 # total number of misses
ul2.replacements                772 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             119809712 # total number of accesses
itlb.hits                 119809676 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47383796 # total number of accesses
dtlb.hits                  47383744 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202372 # total first level page table misses
mem.ptab_accesses        1725030626 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 128 7 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 20:58:18 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 128 7 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 28 # total simulation time in seconds
sim_inst_rate          3571428.6071 # simulation speed (in insts/sec)
sim_total_insn            108982320 # total number of instructions executed
sim_total_refs             50172038 # total number of loads and stores executed
sim_total_loads            29874490 # total number of loads executed
sim_total_stores       20297548.0000 # total number of stores executed
sim_total_branches         11529738 # total number of branches executed
sim_cycle                  81078274 # total simulation time in cycles
sim_IPC                      1.2334 # instructions per cycle
sim_CPI                      0.8108 # cycles per instruction
sim_exec_BW                  1.3442 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 170022091 # cumulative IFQ occupancy
IFQ_fcount                 38427468 # cumulative IFQ full count
ifq_occupancy                2.0970 # avg IFQ occupancy (insn's)
ifq_rate                     1.3442 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5601 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4740 # fraction of time (cycle's) IFQ was full
RUU_count                 628090199 # cumulative RUU occupancy
RUU_fcount                  9998147 # cumulative RUU full count
ruu_occupancy                7.7467 # avg RUU occupancy (insn's)
ruu_rate                     1.3442 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.7632 # avg RUU occupant latency (cycle's)
ruu_full                     0.1233 # fraction of time (cycle's) RUU was full
LSQ_count                 288901066 # cumulative LSQ occupancy
LSQ_fcount                 14990856 # cumulative LSQ full count
lsq_occupancy                3.5632 # avg LSQ occupancy (insn's)
lsq_rate                     1.3442 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.6509 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1849 # fraction of time (cycle's) LSQ was full
sim_slip                 1024037827 # total number of slip cycles
avg_sim_slip                10.2404 # the average slip between issue and retirement
bpred_2lev.lookups         11747919 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        8323692 # total number of address-predicted hits
bpred_2lev.dir_hits         8500635 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1836719 # total number of misses
bpred_2lev.jr_hits          1522988 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8052 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8223 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8960 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1335174 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1549486 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1180976 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9296 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              118334362 # total number of accesses
il1.hits                  113251505 # total number of hits
il1.misses                  5082857 # total number of misses
il1.replacements            5082452 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0430 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0429 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               46760452 # total number of accesses
dl1.hits                   46645006 # total number of hits
dl1.misses                   115446 # total number of misses
dl1.replacements             114934 # total number of replacements
dl1.writebacks                42605 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5240908 # total number of accesses
ul2.hits                    5238785 # total number of hits
ul2.misses                     2123 # total number of misses
ul2.replacements                772 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0001 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             118334362 # total number of accesses
itlb.hits                 118334326 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47135274 # total number of accesses
dtlb.hits                  47135222 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202434 # total first level page table misses
mem.ptab_accesses        1719838056 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 512 9 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 20:58:46 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 512 9 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 28 # total simulation time in seconds
sim_inst_rate          3571428.6071 # simulation speed (in insts/sec)
sim_total_insn            107851896 # total number of instructions executed
sim_total_refs             49657770 # total number of loads and stores executed
sim_total_loads            29568142 # total number of loads executed
sim_total_stores       20089628.0000 # total number of stores executed
sim_total_branches         11367186 # total number of branches executed
sim_cycle                  79391237 # total simulation time in cycles
sim_IPC                      1.2596 # instructions per cycle
sim_CPI                      0.7939 # cycles per instruction
sim_exec_BW                  1.3585 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 168820172 # cumulative IFQ occupancy
IFQ_fcount                 38150939 # cumulative IFQ full count
ifq_occupancy                2.1264 # avg IFQ occupancy (insn's)
ifq_rate                     1.3585 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5653 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4805 # fraction of time (cycle's) IFQ was full
RUU_count                 628599889 # cumulative RUU occupancy
RUU_fcount                 10026955 # cumulative RUU full count
ruu_occupancy                7.9177 # avg RUU occupancy (insn's)
ruu_rate                     1.3585 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.8284 # avg RUU occupant latency (cycle's)
ruu_full                     0.1263 # fraction of time (cycle's) RUU was full
LSQ_count                 288664534 # cumulative LSQ occupancy
LSQ_fcount                 15095120 # cumulative LSQ full count
lsq_occupancy                3.6360 # avg LSQ occupancy (insn's)
lsq_rate                     1.3585 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.6765 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1901 # fraction of time (cycle's) LSQ was full
sim_slip                 1029310913 # total number of slip cycles
avg_sim_slip                10.2931 # the average slip between issue and retirement
bpred_2lev.lookups         11604026 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        8646682 # total number of address-predicted hits
bpred_2lev.dir_hits         8823741 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1513613 # total number of misses
bpred_2lev.jr_hits          1522873 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8365 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8536 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8959 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1329343 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1487983 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1180861 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9295 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              116532854 # total number of accesses
il1.hits                  111547050 # total number of hits
il1.misses                  4985804 # total number of misses
il1.replacements            4985398 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0428 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0428 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               46624677 # total number of accesses
dl1.hits                   46509242 # total number of hits
dl1.misses                   115435 # total number of misses
dl1.replacements             114923 # total number of replacements
dl1.writebacks                42595 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5143834 # total number of accesses
ul2.hits                    5141712 # total number of hits
ul2.misses                     2122 # total number of misses
ul2.replacements                772 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0002 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             116532854 # total number of accesses
itlb.hits                 116532818 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              47008889 # total number of accesses
dtlb.hits                  47008837 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202484 # total first level page table misses
mem.ptab_accesses        1715147286 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/eon.exe chair.control.cook chair.camera chair.surfaces chair.cook.ppm ppm pixels_out.cook 

sim: simulation started @ Fri Oct 25 20:59:14 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
getting pixel output filename pixels_out.cook
opening control file chair.control.cook
opening camera file chair.camera
opening surfaces file chair.surfaces
reading data
processing 8parts
Grid measure is 6 by 3.0001 by 6
cell dimension is 0.863065
Creating grid for list of length 21
Grid size = 7 by 4 by 7
Total occupancy = 236
reading control stream
reading camera stream
Writing to chair.cook.ppm
calculating 150 by 150 image with 400 samples
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               45809995 # total number of loads and stores committed
sim_num_loads              26441675 # total number of loads committed
sim_num_stores         19368320.0000 # total number of stores committed
sim_num_branches           10337355 # total number of branches committed
sim_elapsed_time                 28 # total simulation time in seconds
sim_inst_rate          3571428.6071 # simulation speed (in insts/sec)
sim_total_insn            106310084 # total number of instructions executed
sim_total_refs             48786256 # total number of loads and stores executed
sim_total_loads            28803667 # total number of loads executed
sim_total_stores       19982589.0000 # total number of stores executed
sim_total_branches         11216527 # total number of branches executed
sim_cycle                  77845951 # total simulation time in cycles
sim_IPC                      1.2846 # instructions per cycle
sim_CPI                      0.7785 # cycles per instruction
sim_exec_BW                  1.3656 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.6737 # instruction per branch
IFQ_count                 166364865 # cumulative IFQ occupancy
IFQ_fcount                 37612778 # cumulative IFQ full count
ifq_occupancy                2.1371 # avg IFQ occupancy (insn's)
ifq_rate                     1.3656 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.5649 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4832 # fraction of time (cycle's) IFQ was full
RUU_count                 624938193 # cumulative RUU occupancy
RUU_fcount                 10164360 # cumulative RUU full count
ruu_occupancy                8.0279 # avg RUU occupancy (insn's)
ruu_rate                     1.3656 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.8784 # avg RUU occupant latency (cycle's)
ruu_full                     0.1306 # fraction of time (cycle's) RUU was full
LSQ_count                 286561500 # cumulative LSQ occupancy
LSQ_fcount                 15038849 # cumulative LSQ full count
lsq_occupancy                3.6811 # avg LSQ occupancy (insn's)
lsq_rate                     1.3656 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.6955 # avg LSQ occupant latency (cycle's)
lsq_full                     0.1932 # fraction of time (cycle's) LSQ was full
sim_slip                 1030985065 # total number of slip cycles
avg_sim_slip                10.3099 # the average slip between issue and retirement
bpred_2lev.lookups         11412228 # total number of bpred lookups
bpred_2lev.updates         10337354 # total number of updates
bpred_2lev.addr_hits        8910966 # total number of address-predicted hits
bpred_2lev.dir_hits         9088014 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           1249340 # total number of misses
bpred_2lev.jr_hits          1522879 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1699748 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       342012 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       429390 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8620 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8791 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8959 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.7965 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1320690 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      1462046 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1270358 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1180867 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9296 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              114329580 # total number of accesses
il1.hits                  109372613 # total number of hits
il1.misses                  4956967 # total number of misses
il1.replacements            4956563 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0434 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0434 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               46298337 # total number of accesses
dl1.hits                   46183097 # total number of hits
dl1.misses                   115240 # total number of misses
dl1.replacements             114728 # total number of replacements
dl1.writebacks                42590 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0025 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0025 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0009 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                5114797 # total number of accesses
ul2.hits                    5112675 # total number of hits
ul2.misses                     2122 # total number of misses
ul2.replacements                772 # total number of replacements
ul2.writebacks                  165 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0004 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0002 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             114329580 # total number of accesses
itlb.hits                 114329544 # total number of hits
itlb.misses                      36 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              46694194 # total number of accesses
dtlb.hits                  46694142 # total number of hits
dtlb.misses                      52 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 901120 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                 330704 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120020a30 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  171 # total number of pages allocated
mem.page_mem                  1368k # total size of memory pages allocated
mem.ptab_misses              202484 # total first level page table misses
mem.ptab_accesses        1708762118 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 8 3 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 20:59:42 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 8 3 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 28 # total simulation time in seconds
sim_inst_rate          3571428.6071 # simulation speed (in insts/sec)
sim_total_insn            117809710 # total number of instructions executed
sim_total_refs             39777135 # total number of loads and stores executed
sim_total_loads            30506687 # total number of loads executed
sim_total_stores       9270448.0000 # total number of stores executed
sim_total_branches         20229664 # total number of branches executed
sim_cycle                  77570501 # total simulation time in cycles
sim_IPC                      1.2891 # instructions per cycle
sim_CPI                      0.7757 # cycles per instruction
sim_exec_BW                  1.5187 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 150185009 # cumulative IFQ occupancy
IFQ_fcount                 32125055 # cumulative IFQ full count
ifq_occupancy                1.9361 # avg IFQ occupancy (insn's)
ifq_rate                     1.5187 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2748 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4141 # fraction of time (cycle's) IFQ was full
RUU_count                 587970472 # cumulative RUU occupancy
RUU_fcount                 13346652 # cumulative RUU full count
ruu_occupancy                7.5798 # avg RUU occupancy (insn's)
ruu_rate                     1.5187 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  4.9908 # avg RUU occupant latency (cycle's)
ruu_full                     0.1721 # fraction of time (cycle's) RUU was full
LSQ_count                 202171504 # cumulative LSQ occupancy
LSQ_fcount                  2545381 # cumulative LSQ full count
lsq_occupancy                2.6063 # avg LSQ occupancy (insn's)
lsq_rate                     1.5187 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.7161 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0328 # fraction of time (cycle's) LSQ was full
sim_slip                  858922775 # total number of slip cycles
avg_sim_slip                 8.5892 # the average slip between issue and retirement
bpred_2lev.lookups         21201231 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       11802585 # total number of address-predicted hits
bpred_2lev.dir_hits        11920410 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           4615279 # total number of misses
bpred_2lev.jr_hits          2620471 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7138 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7209 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9468 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3143409 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2937691 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2375254 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9528 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              125221141 # total number of accesses
il1.hits                  121732956 # total number of hits
il1.misses                  3488185 # total number of misses
il1.replacements            3487918 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0279 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0279 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36597717 # total number of accesses
dl1.hits                   36576226 # total number of hits
dl1.misses                    21491 # total number of misses
dl1.replacements              20979 # total number of replacements
dl1.writebacks                10840 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3520516 # total number of accesses
ul2.hits                    3513353 # total number of hits
ul2.misses                     7163 # total number of misses
ul2.replacements               3067 # total number of replacements
ul2.writebacks                 2568 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0020 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0007 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             125221141 # total number of accesses
itlb.hits                 125221124 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36757679 # total number of accesses
dtlb.hits                  36757556 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8236621 # total first level page table misses
mem.ptab_accesses        1500612462 # total page table accesses
mem.ptab_miss_rate           0.0055 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 32 5 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:00:10 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 32 5 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 26 # total simulation time in seconds
sim_inst_rate          3846153.8846 # simulation speed (in insts/sec)
sim_total_insn            120991334 # total number of instructions executed
sim_total_refs             40467472 # total number of loads and stores executed
sim_total_loads            31136435 # total number of loads executed
sim_total_stores       9331037.0000 # total number of stores executed
sim_total_branches         20627792 # total number of branches executed
sim_cycle                  79716614 # total simulation time in cycles
sim_IPC                      1.2544 # instructions per cycle
sim_CPI                      0.7972 # cycles per instruction
sim_exec_BW                  1.5178 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 153324570 # cumulative IFQ occupancy
IFQ_fcount                 32859970 # cumulative IFQ full count
ifq_occupancy                1.9234 # avg IFQ occupancy (insn's)
ifq_rate                     1.5178 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2672 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4122 # fraction of time (cycle's) IFQ was full
RUU_count                 593243286 # cumulative RUU occupancy
RUU_fcount                 13638524 # cumulative RUU full count
ruu_occupancy                7.4419 # avg RUU occupancy (insn's)
ruu_rate                     1.5178 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  4.9032 # avg RUU occupant latency (cycle's)
ruu_full                     0.1711 # fraction of time (cycle's) RUU was full
LSQ_count                 201192224 # cumulative LSQ occupancy
LSQ_fcount                  2416297 # cumulative LSQ full count
lsq_occupancy                2.5238 # avg LSQ occupancy (insn's)
lsq_rate                     1.5178 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.6629 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0303 # fraction of time (cycle's) LSQ was full
sim_slip                  847793849 # total number of slip cycles
avg_sim_slip                 8.4779 # the average slip between issue and retirement
bpred_2lev.lookups         21623696 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       11554711 # total number of address-predicted hits
bpred_2lev.dir_hits        11660935 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           4874754 # total number of misses
bpred_2lev.jr_hits          2632078 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6988 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7052 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9510 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3381877 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2862570 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2386861 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9574 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              127002854 # total number of accesses
il1.hits                  123412024 # total number of hits
il1.misses                  3590830 # total number of misses
il1.replacements            3590562 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0283 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0283 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36736464 # total number of accesses
dl1.hits                   36714969 # total number of hits
dl1.misses                    21495 # total number of misses
dl1.replacements              20983 # total number of replacements
dl1.writebacks                10840 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3623165 # total number of accesses
ul2.hits                    3616003 # total number of hits
ul2.misses                     7162 # total number of misses
ul2.replacements               3066 # total number of replacements
ul2.writebacks                 2567 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0020 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0008 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0007 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             127002854 # total number of accesses
itlb.hits                 127002837 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36879668 # total number of accesses
dtlb.hits                  36879545 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8181251 # total first level page table misses
mem.ptab_accesses        1506857178 # total page table accesses
mem.ptab_miss_rate           0.0054 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 128 7 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:00:37 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 128 7 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 26 # total simulation time in seconds
sim_inst_rate          3846153.8846 # simulation speed (in insts/sec)
sim_total_insn            118338670 # total number of instructions executed
sim_total_refs             39816021 # total number of loads and stores executed
sim_total_loads            30724575 # total number of loads executed
sim_total_stores       9091446.0000 # total number of stores executed
sim_total_branches         20001855 # total number of branches executed
sim_cycle                  76048826 # total simulation time in cycles
sim_IPC                      1.3149 # instructions per cycle
sim_CPI                      0.7605 # cycles per instruction
sim_exec_BW                  1.5561 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 150647970 # cumulative IFQ occupancy
IFQ_fcount                 32403693 # cumulative IFQ full count
ifq_occupancy                1.9809 # avg IFQ occupancy (insn's)
ifq_rate                     1.5561 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2730 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4261 # fraction of time (cycle's) IFQ was full
RUU_count                 590709541 # cumulative RUU occupancy
RUU_fcount                 14221983 # cumulative RUU full count
ruu_occupancy                7.7675 # avg RUU occupancy (insn's)
ruu_rate                     1.5561 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  4.9917 # avg RUU occupant latency (cycle's)
ruu_full                     0.1870 # fraction of time (cycle's) RUU was full
LSQ_count                 200798674 # cumulative LSQ occupancy
LSQ_fcount                  2312490 # cumulative LSQ full count
lsq_occupancy                2.6404 # avg LSQ occupancy (insn's)
lsq_rate                     1.5561 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.6968 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0304 # fraction of time (cycle's) LSQ was full
sim_slip                  852544813 # total number of slip cycles
avg_sim_slip                 8.5254 # the average slip between issue and retirement
bpred_2lev.lookups         20766477 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       12414605 # total number of address-predicted hits
bpred_2lev.dir_hits        12531548 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           4004141 # total number of misses
bpred_2lev.jr_hits          2621365 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7508 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7578 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9472 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3265459 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2735222 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2376148 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9531 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              123127090 # total number of accesses
il1.hits                  119557283 # total number of hits
il1.misses                  3569807 # total number of misses
il1.replacements            3569540 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0290 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0290 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36704649 # total number of accesses
dl1.hits                   36683175 # total number of hits
dl1.misses                    21474 # total number of misses
dl1.replacements              20962 # total number of replacements
dl1.writebacks                10839 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3602120 # total number of accesses
ul2.hits                    3594962 # total number of hits
ul2.misses                     7158 # total number of misses
ul2.replacements               3062 # total number of replacements
ul2.writebacks                 2564 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0020 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0007 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             123127090 # total number of accesses
itlb.hits                 123127073 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36855027 # total number of accesses
dtlb.hits                  36854904 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8207653 # total first level page table misses
mem.ptab_accesses        1497849118 # total page table accesses
mem.ptab_miss_rate           0.0055 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 512 9 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:01:04 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 512 9 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 26 # total simulation time in seconds
sim_inst_rate          3846153.8846 # simulation speed (in insts/sec)
sim_total_insn            116149261 # total number of instructions executed
sim_total_refs             39372483 # total number of loads and stores executed
sim_total_loads            30344968 # total number of loads executed
sim_total_stores       9027515.0000 # total number of stores executed
sim_total_branches         19660383 # total number of branches executed
sim_cycle                  71841550 # total simulation time in cycles
sim_IPC                      1.3920 # instructions per cycle
sim_CPI                      0.7184 # cycles per instruction
sim_exec_BW                  1.6167 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 149108682 # cumulative IFQ occupancy
IFQ_fcount                 32398553 # cumulative IFQ full count
ifq_occupancy                2.0755 # avg IFQ occupancy (insn's)
ifq_rate                     1.6167 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2838 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4510 # fraction of time (cycle's) IFQ was full
RUU_count                 589252479 # cumulative RUU occupancy
RUU_fcount                 14940213 # cumulative RUU full count
ruu_occupancy                8.2021 # avg RUU occupancy (insn's)
ruu_rate                     1.6167 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.0732 # avg RUU occupant latency (cycle's)
ruu_full                     0.2080 # fraction of time (cycle's) RUU was full
LSQ_count                 201181491 # cumulative LSQ occupancy
LSQ_fcount                  2510087 # cumulative LSQ full count
lsq_occupancy                2.8004 # avg LSQ occupancy (insn's)
lsq_rate                     1.6167 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.7321 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0349 # fraction of time (cycle's) LSQ was full
sim_slip                  861159874 # total number of slip cycles
avg_sim_slip                 8.6116 # the average slip between issue and retirement
bpred_2lev.lookups         20337319 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       13303144 # total number of address-predicted hits
bpred_2lev.dir_hits        13420974 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           3114715 # total number of misses
bpred_2lev.jr_hits          2620471 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8045 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8116 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9468 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3333160 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2677844 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2375254 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9528 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              120457313 # total number of accesses
il1.hits                  117098190 # total number of hits
il1.misses                  3359123 # total number of misses
il1.replacements            3358861 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0279 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0279 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36492457 # total number of accesses
dl1.hits                   36470996 # total number of hits
dl1.misses                    21461 # total number of misses
dl1.replacements              20949 # total number of replacements
dl1.writebacks                10839 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3391423 # total number of accesses
ul2.hits                    3384265 # total number of hits
ul2.misses                     7158 # total number of misses
ul2.replacements               3062 # total number of replacements
ul2.writebacks                 2564 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0021 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0008 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             120457313 # total number of accesses
itlb.hits                 120457296 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36645218 # total number of accesses
dtlb.hits                  36645095 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8126461 # total first level page table misses
mem.ptab_accesses        1490867282 # total page table accesses
mem.ptab_miss_rate           0.0055 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/equake.exe 

sim: simulation started @ Fri Oct 25 21:01:30 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
../../exe/equake.exe: Reading nodes.
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000001 # total number of instructions committed
sim_num_refs               35365793 # total number of loads and stores committed
sim_num_loads              26880458 # total number of loads committed
sim_num_stores         8485335.0000 # total number of stores committed
sim_num_branches           16535689 # total number of branches committed
sim_elapsed_time                 26 # total simulation time in seconds
sim_inst_rate          3846153.8846 # simulation speed (in insts/sec)
sim_total_insn            114623805 # total number of instructions executed
sim_total_refs             38965491 # total number of loads and stores executed
sim_total_loads            29926913 # total number of loads executed
sim_total_stores       9038578.0000 # total number of stores executed
sim_total_branches         19444641 # total number of branches executed
sim_cycle                  70134654 # total simulation time in cycles
sim_IPC                      1.4258 # instructions per cycle
sim_CPI                      0.7013 # cycles per instruction
sim_exec_BW                  1.6343 # total instructions (mis-spec + committed) per cycle
sim_IPB                      6.0475 # instruction per branch
IFQ_count                 147870504 # cumulative IFQ occupancy
IFQ_fcount                 32228647 # cumulative IFQ full count
ifq_occupancy                2.1084 # avg IFQ occupancy (insn's)
ifq_rate                     1.6343 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  1.2901 # avg IFQ occupant latency (cycle's)
ifq_full                     0.4595 # fraction of time (cycle's) IFQ was full
RUU_count                 587359471 # cumulative RUU occupancy
RUU_fcount                 15578772 # cumulative RUU full count
ruu_occupancy                8.3747 # avg RUU occupancy (insn's)
ruu_rate                     1.6343 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  5.1242 # avg RUU occupant latency (cycle's)
ruu_full                     0.2221 # fraction of time (cycle's) RUU was full
LSQ_count                 200891750 # cumulative LSQ occupancy
LSQ_fcount                  2650398 # cumulative LSQ full count
lsq_occupancy                2.8644 # avg LSQ occupancy (insn's)
lsq_rate                     1.6343 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.7526 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0378 # fraction of time (cycle's) LSQ was full
sim_slip                  864175956 # total number of slip cycles
avg_sim_slip                 8.6418 # the average slip between issue and retirement
bpred_2lev.lookups         19994654 # total number of bpred lookups
bpred_2lev.updates         16535689 # total number of updates
bpred_2lev.addr_hits       13737092 # total number of address-predicted hits
bpred_2lev.dir_hits        13854929 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           2680760 # total number of misses
bpred_2lev.jr_hits          2620471 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          2767615 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP       245217 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP       274650 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.8308 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.8379 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.9468 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.8928 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      3261707 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      2611181 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      2492965 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      2375254 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.9528 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              118304044 # total number of accesses
il1.hits                  115024303 # total number of hits
il1.misses                  3279741 # total number of misses
il1.replacements            3279479 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0277 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0277 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               36309529 # total number of accesses
dl1.hits                   36288068 # total number of hits
dl1.misses                    21461 # total number of misses
dl1.replacements              20949 # total number of replacements
dl1.writebacks                10839 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0006 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0006 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0003 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                3312041 # total number of accesses
ul2.hits                    3304887 # total number of hits
ul2.misses                     7154 # total number of misses
ul2.replacements               3058 # total number of replacements
ul2.writebacks                 2561 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0022 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0009 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0008 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             118304044 # total number of accesses
itlb.hits                 118304027 # total number of hits
itlb.misses                      17 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              36469727 # total number of accesses
dtlb.hits                  36469604 # total number of hits
dtlb.misses                     123 # total number of misses
dtlb.replacements                 8 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 237568 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  76576 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x012000cee0 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  198 # total number of pages allocated
mem.page_mem                  1584k # total size of memory pages allocated
mem.ptab_misses             8002401 # total first level page table misses
mem.ptab_accesses        1485111050 # total page table accesses
mem.ptab_miss_rate           0.0054 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 8 3 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:01:56 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 8 3 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 66 # total simulation time in seconds
sim_inst_rate          1515151.5455 # simulation speed (in insts/sec)
sim_total_insn            143894391 # total number of instructions executed
sim_total_refs             34403342 # total number of loads and stores executed
sim_total_loads            27123779 # total number of loads executed
sim_total_stores       7279563.0000 # total number of stores executed
sim_total_branches         30439197 # total number of branches executed
sim_cycle                 115972287 # total simulation time in cycles
sim_IPC                      0.8623 # instructions per cycle
sim_CPI                      1.1597 # cycles per instruction
sim_exec_BW                  1.2408 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 298033620 # cumulative IFQ occupancy
IFQ_fcount                 67825308 # cumulative IFQ full count
ifq_occupancy                2.5699 # avg IFQ occupancy (insn's)
ifq_rate                     1.2408 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.0712 # avg IFQ occupant latency (cycle's)
ifq_full                     0.5848 # fraction of time (cycle's) IFQ was full
RUU_count                1084063985 # cumulative RUU occupancy
RUU_fcount                 39160235 # cumulative RUU full count
ruu_occupancy                9.3476 # avg RUU occupancy (insn's)
ruu_rate                     1.2408 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  7.5337 # avg RUU occupant latency (cycle's)
ruu_full                     0.3377 # fraction of time (cycle's) RUU was full
LSQ_count                 290467403 # cumulative LSQ occupancy
LSQ_fcount                  4287133 # cumulative LSQ full count
lsq_occupancy                2.5046 # avg LSQ occupancy (insn's)
lsq_rate                     1.2408 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.0186 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0370 # fraction of time (cycle's) LSQ was full
sim_slip                 1243808994 # total number of slip cycles
avg_sim_slip                12.4381 # the average slip between issue and retirement
bpred_2lev.lookups         33409370 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       12462619 # total number of address-predicted hits
bpred_2lev.dir_hits        12853182 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           6849448 # total number of misses
bpred_2lev.jr_hits          1018945 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6325 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6524 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.7231 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      2217724 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      3897300 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1005291 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.7204 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              163003810 # total number of accesses
il1.hits                  161336359 # total number of hits
il1.misses                  1667451 # total number of misses
il1.replacements            1666993 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0102 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0102 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               27220545 # total number of accesses
dl1.hits                   26840158 # total number of hits
dl1.misses                   380387 # total number of misses
dl1.replacements             379875 # total number of replacements
dl1.writebacks               119284 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0140 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0140 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0044 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2167122 # total number of accesses
ul2.hits                    2044192 # total number of hits
ul2.misses                   122930 # total number of misses
ul2.replacements             118834 # total number of replacements
ul2.writebacks                48002 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0567 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0548 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0222 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             163003810 # total number of accesses
itlb.hits                 163003779 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              27318963 # total number of accesses
dtlb.hits                  27297418 # total number of hits
dtlb.misses                   21545 # total number of misses
dtlb.replacements             21417 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0008 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              254080 # total first level page table misses
mem.ptab_accesses        1117046326 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 32 5 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:03:02 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 32 5 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 25 # total simulation time in seconds
sim_inst_rate          4000000.0800 # simulation speed (in insts/sec)
sim_total_insn            138957733 # total number of instructions executed
sim_total_refs             32969808 # total number of loads and stores executed
sim_total_loads            25920161 # total number of loads executed
sim_total_stores       7049647.0000 # total number of stores executed
sim_total_branches         29223654 # total number of branches executed
sim_cycle                 112343739 # total simulation time in cycles
sim_IPC                      0.8901 # instructions per cycle
sim_CPI                      1.1234 # cycles per instruction
sim_exec_BW                  1.2369 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 291947829 # cumulative IFQ occupancy
IFQ_fcount                 66735050 # cumulative IFQ full count
ifq_occupancy                2.5987 # avg IFQ occupancy (insn's)
ifq_rate                     1.2369 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1010 # avg IFQ occupant latency (cycle's)
ifq_full                     0.5940 # fraction of time (cycle's) IFQ was full
RUU_count                1072727695 # cumulative RUU occupancy
RUU_fcount                 39307523 # cumulative RUU full count
ruu_occupancy                9.5486 # avg RUU occupancy (insn's)
ruu_rate                     1.2369 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  7.7198 # avg RUU occupant latency (cycle's)
ruu_full                     0.3499 # fraction of time (cycle's) RUU was full
LSQ_count                 282176579 # cumulative LSQ occupancy
LSQ_fcount                  4323549 # cumulative LSQ full count
lsq_occupancy                2.5117 # avg LSQ occupancy (insn's)
lsq_rate                     1.2369 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.0307 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0385 # fraction of time (cycle's) LSQ was full
sim_slip                 1251510081 # total number of slip cycles
avg_sim_slip                12.5151 # the average slip between issue and retirement
bpred_2lev.lookups         32070085 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       13055414 # total number of address-predicted hits
bpred_2lev.dir_hits        13392497 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           6310133 # total number of misses
bpred_2lev.jr_hits          1072409 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.6626 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.6797 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.7610 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      2135057 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      3645486 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1058755 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.7587 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              156707003 # total number of accesses
il1.hits                  155020628 # total number of hits
il1.misses                  1686375 # total number of misses
il1.replacements            1685920 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0108 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0108 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               26755298 # total number of accesses
dl1.hits                   26374585 # total number of hits
dl1.misses                   380713 # total number of misses
dl1.replacements             380201 # total number of replacements
dl1.writebacks               118820 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0142 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0142 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0044 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2185908 # total number of accesses
ul2.hits                    2062654 # total number of hits
ul2.misses                   123254 # total number of misses
ul2.replacements             119158 # total number of replacements
ul2.writebacks                48022 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0564 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0545 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0220 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             156707003 # total number of accesses
itlb.hits                 156706972 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              26865172 # total number of accesses
dtlb.hits                  26843404 # total number of hits
dtlb.misses                   21768 # total number of misses
dtlb.replacements             21640 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0008 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              254610 # total first level page table misses
mem.ptab_accesses        1100255700 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 128 7 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:03:27 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 128 7 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 23 # total simulation time in seconds
sim_inst_rate          4347826.1739 # simulation speed (in insts/sec)
sim_total_insn            136080412 # total number of instructions executed
sim_total_refs             32399882 # total number of loads and stores executed
sim_total_loads            25257831 # total number of loads executed
sim_total_stores       7142051.0000 # total number of stores executed
sim_total_branches         28728575 # total number of branches executed
sim_cycle                 108821334 # total simulation time in cycles
sim_IPC                      0.9189 # instructions per cycle
sim_CPI                      1.0882 # cycles per instruction
sim_exec_BW                  1.2505 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 287930800 # cumulative IFQ occupancy
IFQ_fcount                 65860729 # cumulative IFQ full count
ifq_occupancy                2.6459 # avg IFQ occupancy (insn's)
ifq_rate                     1.2505 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1159 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6052 # fraction of time (cycle's) IFQ was full
RUU_count                1070078856 # cumulative RUU occupancy
RUU_fcount                 39776609 # cumulative RUU full count
ruu_occupancy                9.8334 # avg RUU occupancy (insn's)
ruu_rate                     1.2505 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  7.8636 # avg RUU occupant latency (cycle's)
ruu_full                     0.3655 # fraction of time (cycle's) RUU was full
LSQ_count                 283531776 # cumulative LSQ occupancy
LSQ_fcount                  4431260 # cumulative LSQ full count
lsq_occupancy                2.6055 # avg LSQ occupancy (insn's)
lsq_rate                     1.2505 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.0836 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0407 # fraction of time (cycle's) LSQ was full
sim_slip                 1291109324 # total number of slip cycles
avg_sim_slip                12.9111 # the average slip between issue and retirement
bpred_2lev.lookups         31352717 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       13811015 # total number of address-predicted hits
bpred_2lev.dir_hits        14091132 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5611498 # total number of misses
bpred_2lev.jr_hits          1129391 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7010 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7152 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8015 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1949864 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      3422861 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1115737 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.7995 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              151690992 # total number of accesses
il1.hits                  150070314 # total number of hits
il1.misses                  1620678 # total number of misses
il1.replacements            1620222 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0107 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0107 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               26550787 # total number of accesses
dl1.hits                   26171701 # total number of hits
dl1.misses                   379086 # total number of misses
dl1.replacements             378574 # total number of replacements
dl1.writebacks               118772 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0143 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0143 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0045 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2118536 # total number of accesses
ul2.hits                    1995933 # total number of hits
ul2.misses                   122603 # total number of misses
ul2.replacements             118507 # total number of replacements
ul2.writebacks                47983 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0579 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0559 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0226 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             151690992 # total number of accesses
itlb.hits                 151690961 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              26689373 # total number of accesses
dtlb.hits                  26667670 # total number of hits
dtlb.misses                   21703 # total number of misses
dtlb.replacements             21575 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0008 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              254096 # total first level page table misses
mem.ptab_accesses        1088015166 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 512 9 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:03:51 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 512 9 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 21 # total simulation time in seconds
sim_inst_rate          4761904.8571 # simulation speed (in insts/sec)
sim_total_insn            132950078 # total number of instructions executed
sim_total_refs             31731441 # total number of loads and stores executed
sim_total_loads            24568918 # total number of loads executed
sim_total_stores       7162523.0000 # total number of stores executed
sim_total_branches         28133353 # total number of branches executed
sim_cycle                 105876075 # total simulation time in cycles
sim_IPC                      0.9445 # instructions per cycle
sim_CPI                      1.0588 # cycles per instruction
sim_exec_BW                  1.2557 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 285084494 # cumulative IFQ occupancy
IFQ_fcount                 65610161 # cumulative IFQ full count
ifq_occupancy                2.6926 # avg IFQ occupancy (insn's)
ifq_rate                     1.2557 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1443 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6197 # fraction of time (cycle's) IFQ was full
RUU_count                1062974473 # cumulative RUU occupancy
RUU_fcount                 39937451 # cumulative RUU full count
ruu_occupancy               10.0398 # avg RUU occupancy (insn's)
ruu_rate                     1.2557 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  7.9953 # avg RUU occupant latency (cycle's)
ruu_full                     0.3772 # fraction of time (cycle's) RUU was full
LSQ_count                 283150309 # cumulative LSQ occupancy
LSQ_fcount                  4456768 # cumulative LSQ full count
lsq_occupancy                2.6744 # avg LSQ occupancy (insn's)
lsq_rate                     1.2557 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.1297 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0421 # fraction of time (cycle's) LSQ was full
sim_slip                 1292221772 # total number of slip cycles
avg_sim_slip                12.9222 # the average slip between issue and retirement
bpred_2lev.lookups         30548388 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       14330393 # total number of address-predicted hits
bpred_2lev.dir_hits        14508351 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           5194279 # total number of misses
bpred_2lev.jr_hits          1231558 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7273 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7364 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8740 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1802693 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      3299189 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1217904 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.8727 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              148503670 # total number of accesses
il1.hits                  146907458 # total number of hits
il1.misses                  1596212 # total number of misses
il1.replacements            1595759 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0107 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0107 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               26302932 # total number of accesses
dl1.hits                   25924962 # total number of hits
dl1.misses                   377970 # total number of misses
dl1.replacements             377458 # total number of replacements
dl1.writebacks               118652 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0144 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0144 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0045 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2092834 # total number of accesses
ul2.hits                    1970506 # total number of hits
ul2.misses                   122328 # total number of misses
ul2.replacements             118232 # total number of replacements
ul2.writebacks                47950 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0585 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0565 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0229 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             148503670 # total number of accesses
itlb.hits                 148503639 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              26443563 # total number of accesses
dtlb.hits                  26421945 # total number of hits
dtlb.misses                   21618 # total number of misses
dtlb.replacements             21490 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0008 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              254674 # total first level page table misses
mem.ptab_accesses        1079025600 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

sim-outorder: SimpleScalar/Alpha Tool Set version 3.0 of August, 2003.
Copyright (c) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
All Rights Reserved. This version of SimpleScalar is licensed for academic
non-commercial use.  No portion of this work may be used by any commercial
entity, or for any commercial purpose, without the prior written permission
of SimpleScalar, LLC (info@simplescalar.com).

warning: section `.comment' ignored...
sim: command line: sim-outorder -fastfwd 100000000 -max:inst 100000000 -bpred 2lev -bpred:2lev 1 2048 11 0 -mem:width 32 -mem:lat 300 2 ../../exe/vpr.exe net.in arch.in place.out dum.out -nodisp -place_only -init_t 5 -exit_t 0.005 -alpha_t 0.9412 -inner_num 2 

sim: simulation started @ Fri Oct 25 21:04:13 2024, options follow:

sim-outorder: This simulator implements a very detailed out-of-order issue
superscalar processor with a two-level memory system and speculative
execution support.  This simulator is a performance simulator, tracking the
latency of all pipeline operations.

# -config                     # load configuration from a file
# -dumpconfig                 # dump configuration to a file
# -h                    false # print help message    
# -v                    false # verbose operation     
# -d                    false # enable debug message  
# -i                    false # start in Dlite debugger
-seed                       1 # random number generator seed (0 for timer seed)
# -q                    false # initialize and terminate immediately
# -chkpt               <null> # restore EIO trace execution from <fname>
# -redir:sim           <null> # redirect simulator output to file (non-interactive only)
# -redir:prog          <null> # redirect simulated program output to file
-nice                       0 # simulator scheduling priority
-max:inst           100000000 # maximum number of inst's to execute
-fastfwd            100000000 # number of insts skipped before timing starts
# -ptrace              <null> # generate pipetrace, i.e., <fname|stdout|stderr> <range>
-fetch:ifqsize              4 # instruction fetch queue size (in insts)
-fetch:mplat                3 # extra branch mis-prediction latency
-fetch:speed                1 # speed of front-end of machine relative to execution core
-bpred                   2lev # branch predictor type {nottaken|taken|perfect|bimod|2lev|comb}
-bpred:bimod     2048 # bimodal predictor config (<table size>)
-bpred:2lev      1 2048 11 0 # 2-level predictor config (<l1size> <l2size> <hist_size> <xor>)
-bpred:comb      1024 # combining predictor config (<meta_table_size>)
-bpred:ras                  8 # return address stack size (0 for no return stack)
-bpred:btb       512 4 # BTB config (<num_sets> <associativity>)
# -bpred:spec_update       <null> # speculative predictors update in {ID|WB} (default non-spec)
-decode:width               4 # instruction decode B/W (insts/cycle)
-issue:width                4 # instruction issue B/W (insts/cycle)
-issue:inorder          false # run pipeline with in-order issue
-issue:wrongpath         true # issue instructions down wrong execution paths
-commit:width               4 # instruction commit B/W (insts/cycle)
-ruu:size                  16 # register update unit (RUU) size
-lsq:size                   8 # load/store queue (LSQ) size
-cache:dl1       dl1:128:32:4:l # l1 data cache config, i.e., {<config>|none}
-cache:dl1lat               1 # l1 data cache hit latency (in cycles)
-cache:dl2       ul2:1024:64:4:l # l2 data cache config, i.e., {<config>|none}
-cache:dl2lat               6 # l2 data cache hit latency (in cycles)
-cache:il1       il1:512:32:1:l # l1 inst cache config, i.e., {<config>|dl1|dl2|none}
-cache:il1lat               1 # l1 instruction cache hit latency (in cycles)
-cache:il2                dl2 # l2 instruction cache config, i.e., {<config>|dl2|none}
-cache:il2lat               6 # l2 instruction cache hit latency (in cycles)
-cache:flush            false # flush caches on system calls
-cache:icompress        false # convert 64-bit inst addresses to 32-bit inst equivalents
-mem:lat         300 2 # memory access latency (<first_chunk> <inter_chunk>)
-mem:width                 32 # memory access bus width (in bytes)
-tlb:itlb        itlb:16:4096:4:l # instruction TLB config, i.e., {<config>|none}
-tlb:dtlb        dtlb:32:4096:4:l # data TLB config, i.e., {<config>|none}
-tlb:lat                   30 # inst/data TLB miss latency (in cycles)
-res:ialu                   4 # total number of integer ALU's available
-res:imult                  1 # total number of integer multiplier/dividers available
-res:memport                2 # total number of memory system ports available (to CPU)
-res:fpalu                  4 # total number of floating point ALU's available
-res:fpmult                 1 # total number of floating point multiplier/dividers available
# -pcstat              <null> # profile stat(s) against text addr's (mult uses ok)
-bugcompat              false # operate in backward-compatible bugs mode (for testing only)

  Pipetrace range arguments are formatted as follows:

    {{@|#}<start>}:{{@|#|+}<end>}

  Both ends of the range are optional, if neither are specified, the entire
  execution is traced.  Ranges that start with a `@' designate an address
  range to be traced, those that start with an `#' designate a cycle count
  range.  All other range values represent an instruction count range.  The
  second argument, if specified with a `+', indicates a value relative
  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may
  be used in all contexts.

    Examples:   -ptrace FOO.trc #0:#1000
                -ptrace BAR.trc @2000:
                -ptrace BLAH.trc :1500
                -ptrace UXXE.trc :
                -ptrace FOOBAR.trc @main:+278

  Branch predictor configuration examples for 2-level predictor:
    Configurations:   N, M, W, X
      N   # entries in first level (# of shift register(s))
      W   width of shift register(s)
      M   # entries in 2nd level (# of counters, or other FSM)
      X   (yes-1/no-0) xor history and address for 2nd level index
    Sample predictors:
      GAg     : 1, W, 2^W, 0
      GAp     : 1, W, M (M > 2^W), 0
      PAg     : N, W, 2^W, 0
      PAp     : N, W, M (M == 2^(N+W)), 0
      gshare  : 1, W, 2^W, 1
  Predictor `comb' combines a bimodal and a 2-level predictor.

  The cache config parameter <config> has the following format:

    <name>:<nsets>:<bsize>:<assoc>:<repl>

    <name>   - name of the cache being defined
    <nsets>  - number of sets in the cache
    <bsize>  - block size of the cache
    <assoc>  - associativity of the cache
    <repl>   - block replacement strategy, 'l'-LRU, 'f'-FIFO, 'r'-random

    Examples:   -cache:dl1 dl1:4096:32:1:l
                -dtlb dtlb:128:4096:32:r

  Cache levels can be unified by pointing a level of the instruction cache
  hierarchy at the data cache hiearchy using the "dl1" and "dl2" cache
  configuration arguments.  Most sensible combinations are supported, e.g.,

    A unified l2 cache (il2 is pointed at dl2):
      -cache:il1 il1:128:64:1:l -cache:il2 dl2
      -cache:dl1 dl1:256:32:1:l -cache:dl2 ul2:1024:64:2:l

    Or, a fully unified cache hierarchy (il1 pointed at dl1):
      -cache:il1 dl1
      -cache:dl1 ul1:256:32:1:l -cache:dl2 ul2:1024:64:2:l



sim: ** fast forwarding 100000000 insts **
sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn              100000002 # total number of instructions committed
sim_num_refs               23147907 # total number of loads and stores committed
sim_num_loads              18700740 # total number of loads committed
sim_num_stores         4447167.0000 # total number of stores committed
sim_num_branches           19702631 # total number of branches committed
sim_elapsed_time                 22 # total simulation time in seconds
sim_inst_rate          4545454.6364 # simulation speed (in insts/sec)
sim_total_insn            131243078 # total number of instructions executed
sim_total_refs             31393431 # total number of loads and stores executed
sim_total_loads            24211502 # total number of loads executed
sim_total_stores       7181929.0000 # total number of stores executed
sim_total_branches         27762453 # total number of branches executed
sim_cycle                 104066822 # total simulation time in cycles
sim_IPC                      0.9609 # instructions per cycle
sim_CPI                      1.0407 # cycles per instruction
sim_exec_BW                  1.2611 # total instructions (mis-spec + committed) per cycle
sim_IPB                      5.0755 # instruction per branch
IFQ_count                 283376292 # cumulative IFQ occupancy
IFQ_fcount                 65381997 # cumulative IFQ full count
ifq_occupancy                2.7230 # avg IFQ occupancy (insn's)
ifq_rate                     1.2611 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  2.1592 # avg IFQ occupant latency (cycle's)
ifq_full                     0.6283 # fraction of time (cycle's) IFQ was full
RUU_count                1059493490 # cumulative RUU occupancy
RUU_fcount                 40172905 # cumulative RUU full count
ruu_occupancy               10.1809 # avg RUU occupancy (insn's)
ruu_rate                     1.2611 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  8.0728 # avg RUU occupant latency (cycle's)
ruu_full                     0.3860 # fraction of time (cycle's) RUU was full
LSQ_count                 282699268 # cumulative LSQ occupancy
LSQ_fcount                  4522185 # cumulative LSQ full count
lsq_occupancy                2.7165 # avg LSQ occupancy (insn's)
lsq_rate                     1.2611 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  2.1540 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0435 # fraction of time (cycle's) LSQ was full
sim_slip                 1296008950 # total number of slip cycles
avg_sim_slip                12.9601 # the average slip between issue and retirement
bpred_2lev.lookups         30078565 # total number of bpred lookups
bpred_2lev.updates         19702630 # total number of updates
bpred_2lev.addr_hits       14715113 # total number of address-predicted hits
bpred_2lev.dir_hits        14887183 # total number of direction-predicted hits (includes addr-hits)
bpred_2lev.misses           4815447 # total number of misses
bpred_2lev.jr_hits          1237439 # total number of address-predicted hits for JR's
bpred_2lev.jr_seen          1409179 # total number of JR's seen
bpred_2lev.jr_non_ras_hits.PP        13654 # total number of address-predicted hits for non-RAS JR's
bpred_2lev.jr_non_ras_seen.PP        13673 # total number of non-RAS JR's seen
bpred_2lev.bpred_addr_rate    0.7469 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_2lev.bpred_dir_rate    0.7556 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_2lev.bpred_jr_rate    0.8781 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_2lev.bpred_jr_non_ras_rate.PP    0.9986 # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_2lev.retstack_pushes      1704308 # total number of address pushed onto ret-addr stack
bpred_2lev.retstack_pops      3227247 # total number of address popped off of ret-addr stack
bpred_2lev.used_ras.PP      1395506 # total number of RAS predictions used
bpred_2lev.ras_hits.PP      1223785 # total number of RAS hits
bpred_2lev.ras_rate.PP    0.8769 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses              146105910 # total number of accesses
il1.hits                  144508495 # total number of hits
il1.misses                  1597415 # total number of misses
il1.replacements            1596965 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0109 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0109 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses               26159954 # total number of accesses
dl1.hits                   25782068 # total number of hits
dl1.misses                   377886 # total number of misses
dl1.replacements             377374 # total number of replacements
dl1.writebacks               118672 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.0144 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0144 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0045 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                2093973 # total number of accesses
ul2.hits                    1971469 # total number of hits
ul2.misses                   122504 # total number of misses
ul2.replacements             118408 # total number of replacements
ul2.writebacks                47972 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.0585 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0565 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0229 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses             146105910 # total number of accesses
itlb.hits                 146105879 # total number of hits
itlb.misses                      31 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0000 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses              26304955 # total number of accesses
dtlb.hits                  26283341 # total number of hits
dtlb.misses                   21614 # total number of misses
dtlb.replacements             21486 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0008 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0008 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base           0x0120000000 # program text (code) segment base
ld_text_size                 409600 # program text (code) size in bytes
ld_data_base           0x0140000000 # program initialized data segment base
ld_data_size                  83856 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry          0x0120015520 # program entry point (initial PC)
ld_environ_base        0x011ff97000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                  428 # total number of pages allocated
mem.page_mem                  3424k # total size of memory pages allocated
mem.ptab_misses              254370 # total first level page table misses
mem.ptab_accesses        1072915990 # total page table accesses
mem.ptab_miss_rate           0.0002 # first level page table miss rate

